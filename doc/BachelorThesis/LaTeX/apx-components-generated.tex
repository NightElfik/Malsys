




\section{Components}

	
	% ======== SvgRenderer2D =====================================================================


\subsection{2D SVG renderer}
\label{Malsys.Processing.Components.Renderers.SvgRenderer2D}
Provides commands for rendering 2D image.
            Result is vector image in SVG (Scalable Vector Graphics, plain text XML).
            Result is by default compressed by GZip (svgz).\paragraph{Type name}
SvgRenderer2D (Renderers.SvgRenderer2D) 	\paragraph{Assignable to interfaces}
		\hyperref[Malsys.Processing.Components.IComponent]{IComponent}%
, 		\hyperref[Malsys.Processing.Components.IProcessComponent]{IProcessComponent}%
, 		\hyperref[Malsys.Processing.Components.IRenderer]{IRenderer}%
, 		\hyperref[Malsys.Processing.Components.Renderers.IRenderer2D]{IRenderer2D}%
	\paragraph{Settable properties}\textcolor{gray}{of 2D SVG renderer}
	\begin{description*}
		\item[margin]
		(accepts value or array)
			-- Margin of result image.
			\\ Expected value: One number (or array with one number) for all margins, array of two numbers for vertical and horizontal margins
            or array of four numbers as top, right, bottom and left margin respectively.
			\\ Default value: 2
		\item[canvasOriginSize]
		(accepts array)
			-- When set it overrides measured dimensions of image and uses given values.
			\\ Expected value: Four numbers representing x, y, width and height of canvas.
			\\ Default value: none
		\item[compressSvg]
		(accepts value)
			-- If set to true result SBG image is compressed by GZip.
            GZipped SVG images are standard and all programs supporting SVG should be able to open it.
            GZipping SVG significantly reduces its size.
			\\ Expected value: true or false
			\\ Default value: true
		\item[scale]
		(accepts value)
			-- Scale of result image.
			\\ Expected value: Positive number.
			\\ Default value: 1
		\item[lineCap]
		(accepts value)
			-- Cap of each rendered line.
			\\ Expected value: 0 for no caps, 1 for square caps, 2 for round caps
			\\ Default value: 2 (round caps)
	\end{description*}
	
	% ======== BaseRenderer3D =====================================================================


\subsection{3D renderer base}
\label{Malsys.Processing.Components.Renderers.BaseRenderer3D}
Provides commands for rendering 3D scene and also
            some basic functionality common for all 3D renderers.	\paragraph{Abstract component} (can not be instantiated)
\paragraph{Type name}
BaseRenderer3D (Renderers.BaseRenderer3D) 	\paragraph{Derived components}
		\hyperref[Malsys.Processing.Components.Renderers.ThreeJsSceneRenderer3D]{ThreeJsSceneRenderer3D}%
	\paragraph{Derived interfaces}
		\hyperref[Malsys.Processing.Components.IComponent]{IComponent}%
, 		\hyperref[Malsys.Processing.Components.IProcessComponent]{IProcessComponent}%
, 		\hyperref[Malsys.Processing.Components.IRenderer]{IRenderer}%
, 		\hyperref[Malsys.Processing.Components.Renderers.IRenderer3D]{IRenderer3D}%
	
	% ======== ThreeJsSceneRenderer3D =====================================================================


\subsection{3D Three.js renderer}
\label{Malsys.Processing.Components.Renderers.ThreeJsSceneRenderer3D}
Provides commands for rendering 3D scene.
            Result is JavaScript script defining 3D scene in JavaScript 3D engine Three.js.\paragraph{Type name}
ThreeJsSceneRenderer3D (Renderers.ThreeJsSceneRenderer3D) 	\paragraph{Base components}
		\hyperref[Malsys.Processing.Components.Renderers.BaseRenderer3D]{BaseRenderer3D}%
	\paragraph{Assignable to interfaces}
		\hyperref[Malsys.Processing.Components.IComponent]{IComponent}%
, 		\hyperref[Malsys.Processing.Components.IProcessComponent]{IProcessComponent}%
, 		\hyperref[Malsys.Processing.Components.IRenderer]{IRenderer}%
, 		\hyperref[Malsys.Processing.Components.Renderers.IRenderer3D]{IRenderer3D}%
	\paragraph{Settable properties}\textcolor{gray}{of 3D Three.js renderer}
	\begin{description*}
		\item[smoothShading]
		(accepts value)
			-- If set to true, triangles will be shaded smoothly.
            This can improve quality of spheres or cylinders but it has no effect on cubes.
            Also it significantly reduces performance of rendering.
			\\ Expected value: true or false
			\\ Default value: false
		\item[polygonTriangulationStrategy]
		(accepts value)
			-- Polygon triangulation strategy.
			\\ Expected value: 0 for "fan from first point",
            1 triangles with minimal angle are prioritized,
            2 triangles with maximal angle are prioritized,
            3 triangles with maximal distance from all other points are prioritized,
            4 triangles with maximal distance from not-yet-triangulated points are prioritized
			\\ Default value: 2
		\item[cameraPosition]
		(accepts array)
			-- Camera position. If not set it is counted automatically.
			\\ Expected value: Array 3 numbers representing x, y and z coordinate of camera position.
			\\ Default value: counted dynamically
		\item[cameraUpVector]
		(accepts array)
			-- Camera up vector.
			\\ Expected value: Array 3 numbers representing x, y and z up vector of camera.
			\\ Default value: \{0, 1, 0\}
		\item[cameraTarget]
		(accepts array)
			-- Camera target. If not set it is counted automatically.
			\\ Expected value: Array 3 numbers representing x, y and z coordinate of camera target.
			\\ Default value: counted dynamically
	\end{description*}
	
	% ======== AxiomProvider =====================================================================


\subsection{Axiom provider}
\label{Malsys.Processing.Components.Common.AxiomProvider}
Provides a symbol property called Axiom which serves as an initial string of symbols of an L-system.\paragraph{Type name}
AxiomProvider (Common.AxiomProvider) 	\paragraph{Base components}
		\hyperref[Malsys.Processing.Components.Common.SymbolProvider]{SymbolProvider}%
	\paragraph{Assignable to interfaces}
		\hyperref[Malsys.Processing.Components.IComponent]{IComponent}%
, 		\hyperref[Malsys.Processing.Components.IProcessComponent]{IProcessComponent}%
, 		\hyperref[Malsys.Processing.Components.ISymbolProvider]{ISymbolProvider}%
	\paragraph{Settable symbol properties}\textcolor{gray}{of Axiom provider}
	\begin{description*}
		\item[axiom]
			-- Initial string of symbols.
            The value is provided to the connected component.
		\item[Symbols]
			-- Symbol string which is provided.
	\end{description*}
	
	% ======== ConstantsDumper =====================================================================


\subsection{Constants dumper}
\label{Malsys.Processing.Components.Common.ConstantsDumper}
Prints all defined constants from the global scope.
            To be able to use this component you will need to process some L-system with it.
            It is possible to define an empty L-system or you can use the Constants L-system from the standard library.
            The process statement may look like this: process Constants with ConstantDumper;\paragraph{Type name}
ConstantsDumper (Common.ConstantsDumper) 	\paragraph{Assignable to interfaces}
		\hyperref[Malsys.Processing.Components.IComponent]{IComponent}%
, 		\hyperref[Malsys.Processing.Components.IProcessStarter]{IProcessStarter}%
	\paragraph{Settable properties}\textcolor{gray}{of Constants dumper}
	\begin{description*}
		\item[DumpAllConstants]
		(accepts value)
			-- Default behavior is to print only constants in main input.
            If this is set to true all constants will be printed.
			\\ Expected value: true or false
			\\ Default value: false
	\end{description*}
	
	% ======== HexaAsciiInterpreter =====================================================================


\subsection{Hexagonal ASCII interpreter}
\label{Malsys.Processing.Components.Interpreters.HexaAsciiInterpreter}
Hexagonal ASCII interpreter interprets symbols as lines on hexagonal grid rendering them as text (ASCII art).\paragraph{Type name}
HexaAsciiInterpreter (Interpreters.HexaAsciiInterpreter) 	\paragraph{Assignable to interfaces}
		\hyperref[Malsys.Processing.Components.IComponent]{IComponent}%
, 		\hyperref[Malsys.Processing.Components.IInterpreter]{IInterpreter}%
, 		\hyperref[Malsys.Processing.Components.IProcessComponent]{IProcessComponent}%
	\paragraph{Settable properties}\textcolor{gray}{of Hexagonal ASCII interpreter}
	\begin{description*}
		\item[scale]
		(accepts value)
			-- Scale of result ASCII art.
            Value representing number of characters to draw per line.
			\\ Expected value: Positive number.
			\\ Default value: 1
		\item[horizontalScaleMultiplier]
		(accepts value)
			-- Horizontal scale multiplier is used to multiply number of characters per horizontal line.
            Default value is 2 because ordinary characters are 2 times taller than wider.
			\\ Expected value: Positive number.
			\\ Default value: 2
	\end{description*}
	\paragraph{Connectable properties}\textcolor{gray}{of Hexagonal ASCII interpreter}
	\begin{description*}
		\item[Renderer]
		(connectable type:  \hyperref[Malsys.Processing.Components.IRenderer]{IRenderer})
			-- Render for rendering of ASCII art.
            Connected renderer must implement ITextRenderer interface.
	\end{description*}
	\paragraph{Interpretation methods}\textcolor{gray}{of Hexagonal ASCII interpreter}
	\begin{description*}
		\item[Nothing]
			-- Symbol is ignored.
		\\ Parameters: 0 
		\item[MoveForward]
			-- Moves forward (without drawing) by one tile in current direction.
		\\ Parameters: 0 
		\item[DrawLine]
			-- Draws line (from characters) in current direction.
		\\ Parameters: 0 
		\item[TurnLeft]
			-- Turns left by 60 degrees.
		\\ Parameters: 0 
		\item[TurnRight]
			-- Turns right by 60 degrees.
		\\ Parameters: 0 
		\item[TurnAround]
			-- Turns by 180 degrees.
		\\ Parameters: 0 
		\item[StartBranch]
			-- Saves current state (on stack).
		\\ Parameters: 0 
		\item[EndBranch]
			-- Loads previously saved state (returns to last saved position).
		\\ Parameters: 0 
	\end{description*}
	
	% ======== InnerLsystemIterator =====================================================================


\subsection{Inner L-system iterator}
\label{Malsys.Processing.Components.RewriterIterators.InnerLsystemIterator}
Specialized iterator for iterating inner L-systems.
            Axiom is directly in iterator as property to optimize number of components.
            AxiomProvider property is ignored.\paragraph{Type name}
InnerLsystemIterator (RewriterIterators.InnerLsystemIterator) 	\paragraph{Base components}
		\hyperref[Malsys.Processing.Components.RewriterIterators.MemoryBufferedIterator]{MemoryBufferedIterator}%
	\paragraph{Assignable to interfaces}
		\hyperref[Malsys.Processing.Components.IComponent]{IComponent}%
, 		\hyperref[Malsys.Processing.Components.IIterator]{IIterator}%
, 		\hyperref[Malsys.Processing.Components.IProcessComponent]{IProcessComponent}%
, 		\hyperref[Malsys.Processing.Components.IProcessStarter]{IProcessStarter}%
, 		\hyperref[Malsys.Processing.Components.ISymbolProvider]{ISymbolProvider}%
	\paragraph{Gettable properties}\textcolor{gray}{of Inner L-system iterator}
	\begin{description*}
		\item[currentIteration]
 \textit{run-time only} 		(returns value)
			-- Number of current iteration. Zero is axiom (no iteration was done), first iteration have number 1
            and last is equal to number of all iterations specified by Iterations property.
		\item[iterations, i]
 \textit{run-time only} 		(returns value)
			-- Number of iterations to do with current L-system.
	\end{description*}
	\paragraph{Settable properties}\textcolor{gray}{of Inner L-system iterator}
	\begin{description*}
		\item[iterations, i]
		(accepts value)
			-- Number of iterations to do with current L-system.
			\\ Expected value: Non-negative number representing number of iterations.
			\\ Default value: 0
		\item[interpretEveryIteration]
		(accepts value)
			-- If set to true iterator will send symbols from all iterations to connected interpret.
            Otherwise only result of last iteration is interpreted.
			\\ Expected value: true or false
			\\ Default value: false
		\item[interpretEveryIterationFrom]
		(accepts value)
			-- Sets interprets all iteration from given number.
			\\ Expected value: true or false
			\\ Default value: false
		\item[interpretFollowingIterations]
		(accepts array)
			-- Array with numbers of iterations which will be interpreted.
			\\ Expected value: Array of numbers
			\\ Default value: \{\} (empty array)
	\end{description*}
	\paragraph{Settable symbol properties}\textcolor{gray}{of Inner L-system iterator}
	\begin{description*}
		\item[axiom]
 \textit{mandatory} 			-- Axiom is directly in iterator to optimize number of components.
	\end{description*}
	\paragraph{Connectable properties}\textcolor{gray}{of Inner L-system iterator}
	\begin{description*}
		\item[AxiomProvider]
 \textit{optional} 		(connectable type:  \hyperref[Malsys.Processing.Components.ISymbolProvider]{ISymbolProvider})
			-- To allow not connecting AxiomProvider component.
		\item[SymbolProvider]
 \textit{optional} 		(connectable type:  \hyperref[Malsys.Processing.Components.ISymbolProvider]{ISymbolProvider})
			-- Iterator iterates symbols by reading all symbols from SymbolProvider every iteration.
            Rewriter should be connected as SymbolProvider and rewriters's SymbolProvider should be this Iterator.
            This setup creates loop and iterator rewrites string of symbols every iteration.
            When number of iterations is set to 0 (of left default as 0) only axiom is used and this that case this property can be left unconnected.
		\item[OutputProcessor]
		(connectable type:  \hyperref[Malsys.Processing.Components.ISymbolProcessor]{ISymbolProcessor})
			-- Result string of symbols is sent to connected output processor.
            It should be InterpretrCaller who calls Interpreter and interprets symbols.
		\item[RandomGeneratorProvider]
 \textit{optional} 		(connectable type:  \hyperref[Malsys.Processing.Components.Common.RandomGeneratorProvider]{RandomGeneratorProvider})
			-- Connected RandomGeneratorProvider's random generator is rested after each iteration
            if iterator is configured to do that (ResetRandomAfterEachIteration property is set to true).
	\end{description*}
	
	% ======== LsystemInLsystemProcessor =====================================================================


\subsection{Inner L-system processor}
\label{Malsys.Processing.Components.Common.LsystemInLsystemProcessor}
This is special component for interpreting an L-system symbol as another L-system.
            The symbol is processed by newly created component system but interpretation calls are processed with all the
            components in the original system.\paragraph{Type name}
LsystemInLsystemProcessor (Common.LsystemInLsystemProcessor) 	\paragraph{Assignable to interfaces}
		\hyperref[Malsys.Processing.Components.Common.ILsystemInLsystemProcessor]{ILsystemInLsystemProcessor}%
, 		\hyperref[Malsys.Processing.Components.IComponent]{IComponent}%
	
	% ======== InterpreterCaller =====================================================================


\subsection{Interpreter caller}
\label{Malsys.Processing.Components.Interpreters.InterpreterCaller}
Process symbols by calling interpretation methods on connected interpreter.
            For conversion are used defined interpretation rules in current L-system.\paragraph{Type name}
InterpreterCaller (Interpreters.InterpreterCaller) 	\paragraph{Assignable to interfaces}
		\hyperref[Malsys.Processing.Components.IComponent]{IComponent}%
, 		\hyperref[Malsys.Processing.Components.IInterpreterCaller]{IInterpreterCaller}%
, 		\hyperref[Malsys.Processing.Components.IProcessComponent]{IProcessComponent}%
, 		\hyperref[Malsys.Processing.Components.ISymbolProcessor]{ISymbolProcessor}%
	\paragraph{Settable properties}\textcolor{gray}{of Interpreter caller}
	\begin{description*}
		\item[debugInterpretation]
		(accepts value)
			-- True if print debug information about interpretation converting.
			\\ Expected value: true or false
			\\ Default value: false
	\end{description*}
	\paragraph{Connectable properties}\textcolor{gray}{of Interpreter caller}
	\begin{description*}
		\item[LsystemInLsystemProcessor]
 \textit{optional} 		(connectable type:  \hyperref[Malsys.Processing.Components.Common.ILsystemInLsystemProcessor]{ILsystemInLsystemProcessor})
			-- Specialized component to allow interpret L-system symbol as another L-system.
	\end{description*}
	
	% ======== MemoryBufferedIterator =====================================================================


\subsection{Memory-buffered iterator}
\label{Malsys.Processing.Components.RewriterIterators.MemoryBufferedIterator}
Iterates L-system from connected symbol provider with connected rewriter.
            Buffers symbols from rewriter in the memory.\paragraph{Type name}
MemoryBufferedIterator (RewriterIterators.MemoryBufferedIterator) 	\paragraph{Derived components}
		\hyperref[Malsys.Processing.Components.RewriterIterators.InnerLsystemIterator]{InnerLsystemIterator}%
	\paragraph{Assignable to interfaces}
		\hyperref[Malsys.Processing.Components.IComponent]{IComponent}%
, 		\hyperref[Malsys.Processing.Components.IIterator]{IIterator}%
, 		\hyperref[Malsys.Processing.Components.IProcessComponent]{IProcessComponent}%
, 		\hyperref[Malsys.Processing.Components.IProcessStarter]{IProcessStarter}%
, 		\hyperref[Malsys.Processing.Components.ISymbolProvider]{ISymbolProvider}%
	\paragraph{Gettable properties}\textcolor{gray}{of Memory-buffered iterator}
	\begin{description*}
		\item[currentIteration]
 \textit{run-time only} 		(returns value)
			-- Number of current iteration. Zero is axiom (no iteration was done), first iteration have number 1
            and last is equal to number of all iterations specified by Iterations property.
		\item[iterations, i]
 \textit{run-time only} 		(returns value)
			-- Number of iterations to do with current L-system.
	\end{description*}
	\paragraph{Settable properties}\textcolor{gray}{of Memory-buffered iterator}
	\begin{description*}
		\item[iterations, i]
		(accepts value)
			-- Number of iterations to do with current L-system.
			\\ Expected value: Non-negative number representing number of iterations.
			\\ Default value: 0
		\item[interpretEveryIteration]
		(accepts value)
			-- If set to true iterator will send symbols from all iterations to connected interpret.
            Otherwise only result of last iteration is interpreted.
			\\ Expected value: true or false
			\\ Default value: false
		\item[interpretEveryIterationFrom]
		(accepts value)
			-- Sets interprets all iteration from given number.
			\\ Expected value: true or false
			\\ Default value: false
		\item[interpretFollowingIterations]
		(accepts array)
			-- Array with numbers of iterations which will be interpreted.
			\\ Expected value: Array of numbers
			\\ Default value: \{\} (empty array)
	\end{description*}
	\paragraph{Connectable properties}\textcolor{gray}{of Memory-buffered iterator}
	\begin{description*}
		\item[SymbolProvider]
 \textit{optional} 		(connectable type:  \hyperref[Malsys.Processing.Components.ISymbolProvider]{ISymbolProvider})
			-- Iterator iterates symbols by reading all symbols from SymbolProvider every iteration.
            Rewriter should be connected as SymbolProvider and rewriters's SymbolProvider should be this Iterator.
            This setup creates loop and iterator rewrites string of symbols every iteration.
            When number of iterations is set to 0 (of left default as 0) only axiom is used and this that case this property can be left unconnected.
		\item[AxiomProvider]
		(connectable type:  \hyperref[Malsys.Processing.Components.ISymbolProvider]{ISymbolProvider})
			-- Axiom provider component provides initial string of symbols.
            All symbols are read at begin of processing.
		\item[OutputProcessor]
		(connectable type:  \hyperref[Malsys.Processing.Components.ISymbolProcessor]{ISymbolProcessor})
			-- Result string of symbols is sent to connected output processor.
            It should be InterpretrCaller who calls Interpreter and interprets symbols.
		\item[RandomGeneratorProvider]
 \textit{optional} 		(connectable type:  \hyperref[Malsys.Processing.Components.Common.RandomGeneratorProvider]{RandomGeneratorProvider})
			-- Connected RandomGeneratorProvider's random generator is rested after each iteration
            if iterator is configured to do that (ResetRandomAfterEachIteration property is set to true).
	\end{description*}
	
	% ======== RandomGeneratorProvider =====================================================================


\subsection{Random generator provider}
\label{Malsys.Processing.Components.Common.RandomGeneratorProvider}
This component offers both, random and pseudo-random generators.
            It provides a callable function called random which can be called even in the L-system definition
            (not only at run-time).
            The pseudo-random number generator is used by default.
            If no random seed is set it will be generated randomly and a message with its value will be sent to the user
            to be possible to reproduce generated result.
            Truly-random generation should be used only by experienced users because other components will not be able to
            measure a generated model and results may be strange.\paragraph{Type name}
RandomGeneratorProvider (Common.RandomGeneratorProvider) 	\paragraph{Assignable to interfaces}
		\hyperref[Malsys.Processing.Components.IComponent]{IComponent}%
	\paragraph{Gettable properties}\textcolor{gray}{of Random generator provider}
	\begin{description*}
		\item[trueRandom]
 \textit{run-time only} 		(returns value)
			-- If set to true as random generator will be used
            true-random (cryptographic random) generator.
            For this random generator can not be set any seed and numbers are
            always unpredictably random.
            If set to false as random generator will be used pseudo-random generator.
		\item[randomSeed]
		(returns value)
			-- If set pseudo-random generator will generate always same sequence of random numbers.
            Do not work if TrueRandom property is set.
	\end{description*}
	\paragraph{Settable properties}\textcolor{gray}{of Random generator provider}
	\begin{description*}
		\item[trueRandom]
		(accepts value)
			-- If set to true as random generator will be used
            true-random (cryptographic random) generator.
            For this random generator can not be set any seed and numbers are
            always unpredictably random.
            If set to false as random generator will be used pseudo-random generator.
			\\ Expected value: true or false
			\\ Default value: false
		\item[randomSeed]
		(accepts value)
			-- If set pseudo-random generator will generate always same sequence of random numbers.
            Do not work if TrueRandom property is set.
			\\ Expected value: Non-negative integer.
			\\ Default value: random
	\end{description*}
	\paragraph{Callable functions}\textcolor{gray}{of Random generator provider}
	\begin{description*}
		\item[random]
		(returns value)
			-- Returns random value from 0.0 (inclusive) to 1.0 (exclusive).
		\\ Parameters: 0
		\item[random]
		(returns value)
			-- Returns random value within specified range.
		\\ Parameters: 2
			\begin{enumerate*}
				\item The inclusive lower bound of the random number returned.
				\item             The exclusive upper bound of the random number returned.
			\end{enumerate*}
	\end{description*}
	
	% ======== SymbolFilter =====================================================================


\subsection{Symbol fileter}
\label{ExamplePlugin.Components.SymbolFilter}
Filters symbol stream.\paragraph{Type name}
SymbolFilter (ExamplePlugin.Components.SymbolFilter) 	\paragraph{Assignable to interfaces}
		\hyperref[Malsys.Processing.Components.IComponent]{IComponent}%
, 		\hyperref[Malsys.Processing.Components.IProcessComponent]{IProcessComponent}%
, 		\hyperref[Malsys.Processing.Components.ISymbolProcessor]{ISymbolProcessor}%
	\paragraph{Settable symbol properties}\textcolor{gray}{of Symbol fileter}
	\begin{description*}
		\item[ignore]
			-- List of ignored symbols.
	\end{description*}
	\paragraph{Connectable properties}\textcolor{gray}{of Symbol fileter}
	\begin{description*}
		\item[Output]
		(connectable type:  \hyperref[Malsys.Processing.Components.ISymbolProcessor]{ISymbolProcessor})
			-- Components to which filtered symbols are sent.
	\end{description*}
	
	% ======== SymbolProvider =====================================================================


\subsection{Symbol provider}
\label{Malsys.Processing.Components.Common.SymbolProvider}
Standard implementation of ISymbolProvider interface.
            It provides all symbols set to the Symbols property regardless of the state of processing.\paragraph{Type name}
SymbolProvider (Common.SymbolProvider) 	\paragraph{Derived components}
		\hyperref[Malsys.Processing.Components.Common.AxiomProvider]{AxiomProvider}%
	\paragraph{Assignable to interfaces}
		\hyperref[Malsys.Processing.Components.IComponent]{IComponent}%
, 		\hyperref[Malsys.Processing.Components.IProcessComponent]{IProcessComponent}%
, 		\hyperref[Malsys.Processing.Components.ISymbolProvider]{ISymbolProvider}%
	\paragraph{Settable symbol properties}\textcolor{gray}{of Symbol provider}
	\begin{description*}
		\item[Symbols]
			-- Symbol string which is provided.
	\end{description*}
	
	% ======== SymbolRewriter =====================================================================


\subsection{Symbol rewriter}
\label{Malsys.Processing.Components.Rewriters.SymbolRewriter}
Full featured symbol rewriter which rewrites symbols based on defined rewrite rules in the L-system.
             It is capable to rewrite symbol based all criteria of Malsys' rewrite rules.
             Rewriting is initiated by symbol request (by enumerator).
             Then rewriter takes as many symbols from connected symbol provider as is needed for rewriting the symbol.
             If contexts (or branches) are long it may load many symbols before returning single one.\paragraph{Type name}
SymbolRewriter (Rewriters.SymbolRewriter) 	\paragraph{Assignable to interfaces}
		\hyperref[Malsys.Processing.Components.IComponent]{IComponent}%
, 		\hyperref[Malsys.Processing.Components.IProcessComponent]{IProcessComponent}%
, 		\hyperref[Malsys.Processing.Components.IRewriter]{IRewriter}%
, 		\hyperref[Malsys.Processing.Components.ISymbolProvider]{ISymbolProvider}%
	\paragraph{Settable symbol properties}\textcolor{gray}{of Symbol rewriter}
	\begin{description*}
		\item[contextIgnore]
			-- List of symbols which are ignored in context checking.
		\item[startBranchSymbols]
			-- List of symbols which are indicating start of branch.
            This symbols should be identical to symbols which are interpreted as start branch.
		\item[endBranchSymbols]
			-- List of symbols which are indicating end of branch.
            This symbols should be identical to symbols which are interpreted as end branch.
	\end{description*}
	\paragraph{Connectable properties}\textcolor{gray}{of Symbol rewriter}
	\begin{description*}
		\item[SymbolProvider]
		(connectable type:  \hyperref[Malsys.Processing.Components.ISymbolProvider]{ISymbolProvider})
	\end{description*}
	
	% ======== SymbolsSaver =====================================================================


\subsection{Symbols saver}
\label{Malsys.Processing.Components.Common.SymbolsSaver}
Prints all processed symbols (with their parameters) as the text.
            Symbols are delimited with a space.\paragraph{Type name}
SymbolsSaver (Common.SymbolsSaver) 	\paragraph{Assignable to interfaces}
		\hyperref[Malsys.Processing.Components.IComponent]{IComponent}%
, 		\hyperref[Malsys.Processing.Components.IProcessComponent]{IProcessComponent}%
, 		\hyperref[Malsys.Processing.Components.ISymbolProcessor]{ISymbolProcessor}%
	
	% ======== TextRenderer =====================================================================


\subsection{Text renderer}
\label{Malsys.Processing.Components.Renderers.TextRenderer}
Provides commands for rendering plain text ASCII art.\paragraph{Type name}
TextRenderer (Renderers.TextRenderer) 	\paragraph{Assignable to interfaces}
		\hyperref[Malsys.Processing.Components.IComponent]{IComponent}%
, 		\hyperref[Malsys.Processing.Components.IProcessComponent]{IProcessComponent}%
, 		\hyperref[Malsys.Processing.Components.IRenderer]{IRenderer}%
, 		\hyperref[Malsys.Processing.Components.Renderers.ITextRenderer]{ITextRenderer}%
	
	% ======== TurtleInterpreter =====================================================================


\subsection{Turtle interpreter}
\label{Malsys.Processing.Components.Interpreters.TurtleInterpreter}
Turtle interpreter interprets symbols as basic 2D or 3D graphics primitives.
            Interpreting is always in 3D but if it is connected 2D renderer (component with interface IRenderer2D) the Z
            coordinate is omitted.\paragraph{Type name}
TurtleInterpreter (Interpreters.TurtleInterpreter) 	\paragraph{Assignable to interfaces}
		\hyperref[Malsys.Processing.Components.IComponent]{IComponent}%
, 		\hyperref[Malsys.Processing.Components.IInterpreter]{IInterpreter}%
, 		\hyperref[Malsys.Processing.Components.Interpreters.IInterpreter2D]{IInterpreter2D}%
, 		\hyperref[Malsys.Processing.Components.Interpreters.IInterpreter3D]{IInterpreter3D}%
, 		\hyperref[Malsys.Processing.Components.IProcessComponent]{IProcessComponent}%
	\paragraph{Gettable properties}\textcolor{gray}{of Turtle interpreter}
	\begin{description*}
		\item[origin]
		(returns array)
			-- Origin (start position) of "turtle".
		\item[forwardVector]
		(returns array)
			-- Forward vector of "turtle".
		\item[upVector]
		(returns array)
			-- Up vector of "turtle".
	\end{description*}
	\paragraph{Settable properties}\textcolor{gray}{of Turtle interpreter}
	\begin{description*}
		\item[origin]
		(accepts array)
			-- Origin (start position) of "turtle".
			\\ Expected value: Array of 2 or 3 numbers representing x, y and optionally z coordinate.
			\\ Default value: \{0, 0, 0\}
		\item[forwardVector]
		(accepts array)
			-- Forward vector of "turtle".
			\\ Expected value: Array of 3 numbers representing x, y and z coordinate.
			\\ Default value: \{1, 0, 0\}
		\item[upVector]
		(accepts array)
			-- Up vector of "turtle".
			\\ Expected value: Array of 3 constants representing x, y and z coordinate.
			\\ Default value: \{0, 1, 0\}
		\item[rotationQuaternion]
		(accepts array)
		\item[initialAngle]
		(accepts value)
			-- Initial angle (in degrees) in 2D mode (angle in plane given by forward and up vectors).
			\\ Expected value: Number representing angle in degrees.
			\\ Default value: 0
		\item[initialLineWidth]
		(accepts value)
			-- Initial width of drawn line.
			\\ Expected value: Number representing width. Unit of value depends on used renderer.
			\\ Default value: 2
		\item[initialColor]
		(accepts value or array)
			-- Initial color of drawn line.
			\\ Expected value: Number representing ARGB color (in range from 0 to 2\^32 - 1) or array of numbers (in range from 0.0 to 1.0) with length of 3 (RGB) or 4 (ARGB).
			\\ Default value: 0 (black)
		\item[continuousColoring]
		(accepts value or array)
			-- Continuous coloring gradient.
            If enabled all colors will be ignored and given gradient (or default gradient of rainbow) will be used to continuously color all objects.
			\\ Expected value: Boolean false disables continuous coloring, true uses default rainbow gradient to continuous coloring.
            	Array representing color gradient can be also set (see documentation or examples for syntax).
			\\ Default value: false
		\item[reversePolygonOrder]
		(accepts value)
			-- Reverses order of drawn polygons from first-opened last-drawn to first-opened first-drawn.
            This in only valid when 2D renderer is attached (in 3D is order insignificant).
			\\ Expected value: true or false
			\\ Default value: false
		\item[tropismVector]
		(accepts array)
			-- Tropism vector affects drawn or moved lines to derive to tropism vector.
			\\ Expected value: Array of 3 constants representing x, y and z coordinate.
			\\ Default value: \{0, 1, 0\}
		\item[tropismCoefficient]
		(accepts value)
			-- Tropism coefficient affects speed of derivation to tropism vector.
			\\ Expected value: Number.
			\\ Default value: 0
	\end{description*}
	\paragraph{Connectable properties}\textcolor{gray}{of Turtle interpreter}
	\begin{description*}
		\item[Renderer]
		(connectable type:  \hyperref[Malsys.Processing.Components.IRenderer]{IRenderer})
			-- All render events will be called on connected renderer.
            Both IRenderer2D or IRenderer3D can be connected.
	\end{description*}
	\paragraph{Interpretation methods}\textcolor{gray}{of Turtle interpreter}
	\begin{description*}
		\item[Nothing]
			-- Symbol is ignored.
		\\ Parameters: 0 
		\item[MoveForward]
			-- Moves forward in current direction (without drawing) by distance equal to value of the first parameter.
		\\ Parameters: 1  (1 mandatory) 
			\begin{enumerate*}
				\item
Moved distance. (\textit{mandatory}) 			\end{enumerate*}
		\item[DrawForward]
			-- Draws line in current direction with length equal to value of first parameter.
		\\ Parameters: 4  (1 mandatory) 
			\begin{enumerate*}
				\item
Length of line. (\textit{mandatory}) 				\item
            Width of line.				\item
            Color of line. Can be ARGB number in range from 0 to 2\^32 - 1 or array with 3 (RGB) or 4 (ARGB) items in range from 0.0 to 1.0.				\item
            Quality of rendered line in 3D.			\end{enumerate*}
		\item[DrawCircle]
			-- Draws circle with center in current position and radius equal to value of the first parameter.
		\\ Parameters: 2  (1 mandatory) 
			\begin{enumerate*}
				\item
Radius of circle. (\textit{mandatory}) 				\item
            Color of circle.			\end{enumerate*}
		\item[DrawSphere]
			-- Draws sphere with center in current position and radius equal to value of the first parameter.
		\\ Parameters: 3  (1 mandatory) 
			\begin{enumerate*}
				\item
Radius of sphere. (\textit{mandatory}) 				\item
            Color of sphere.				\item
            Quality of sphere (number of triangles).			\end{enumerate*}
		\item[TurnLeft]
			-- Turns left by value of the first parameter (in degrees) (in X-Y plane, around axis Z).
		\\ Parameters: 1  (0 mandatory) 
			\begin{enumerate*}
				\item
Angle in degrees.			\end{enumerate*}
		\item[Yaw]
			-- Turns left around up vector axis (default Y axis [0, 1, 0]) by value given in the first parameter (in degrees).
		\\ Parameters: 1  (0 mandatory) 
			\begin{enumerate*}
				\item
Angle in degrees.			\end{enumerate*}
		\item[Pitch]
			-- Turns up around right-hand vector axis (default Z axis [0, 0, 1]) by value given in the first parameter (in degrees).
		\\ Parameters: 1  (0 mandatory) 
			\begin{enumerate*}
				\item
Angle in degrees.			\end{enumerate*}
		\item[Roll]
			-- Rolls clock-wise around forward vector axis (default X axis [1, 0, 0]) by value given in the first parameter (in degrees).
		\\ Parameters: 1  (0 mandatory) 
			\begin{enumerate*}
				\item
Angle in degrees.			\end{enumerate*}
		\item[StartBranch]
			-- Saves current state (on stack).
		\\ Parameters: 0 
		\item[EndBranch]
			-- Loads previously saved state (returns to last saved position).
		\\ Parameters: 0 
		\item[StartPolygon]
			-- Starts to record polygon vertices (do not saves current position as first vertex).
            If another polygon is opened, its state is saved and will be restored after closing of current polygon.
		\\ Parameters: 3  (0 mandatory) 
			\begin{enumerate*}
				\item
Color of polygon.				\item
            Stroke width.				\item
            Stroke color.			\end{enumerate*}
		\item[RecordPolygonVertex]
			-- Records current position to opened polygon.
		\\ Parameters: 0 
		\item[EndPolygon]
			-- Ends current polygon (do not saves current position as last vertex).
		\\ Parameters: 0 
	\end{description*}

