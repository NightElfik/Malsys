
\chapter{Implementation}
\label{chap:implementation}

In this chapter is described implementation of designed system.

Initially the project was names as \emph{Malsys} which stands for \emph{Marks \lsystems} and this name preserved till now.
Thus root namespace is called \emph{Malsys}.

[TODO]


\section{Choice of development environment}

As development environment was chosen .NET because of following reasons.

\begin{description*}
	\item[Multiplatformity]
		Thanks to Mono project\footnote{Mono is an open source implementation of Microsoft's .NET Framework \url{http://www.mono-project.com}}
			.NET libraries and executables can be used not only on Windows but also on Linux, Mac and many other operating systems.
	\item[Development tools]
		Visual Studio is powerful integrated development environment (IDE) with many integrated tools (like inteli-sense, unit testing or T4 templates) and useful downloadable plugins.
	\item[Reflection]
		Reflection is the ability to examine types and work with meta-data, properties and functions of an object at runtime.
		Reflection can be used to load various plugins or data at runtime and help extensibility in great way.
	\item[Parser generator]
		FsLex and FsYacc are lexer and parser generators written in F\# with good support by Visual Studio.
		Generated lexer and parser are also in F\# thus they can be easily used in any .NET project.
	\item[Web framework]
		ASP.NET MVC is a lightweight presentation framework for creating web applications in .NET.
\end{description*}

The most of code will be written in C\# expect input lexer and parser which will be in F\#. 


\section{Solution structure}

The solution is divided into 6 projects: \lsystem processing library (Malsys), web user interface (Malsys.Web), abstract syntax tree (Malsys.Ast), syntax parser (Malsys.Paring), common functionality (Malsys.Common) and project with tests (Malsys.Tests).

The main reason why solution do not contain lower amount of projects is because syntax parser is written in F\# which is also language from .NET family but it is not possible to compile F\# and C\# into single DLL.
Abstract syntax tree (AST) is separated from parser because AST will be compiled by compilers written in C\# and it is desirable to have AST data structures written in C\#.
It is also more comfortable to design AST classes in C\# because F\# is functional language and syntax of classes definition is quite complex.
Common functionality is separated into single project because it will be needed in all projects and solution can not have circular dependencies of projects.
Web project is separated from main project intentionally to allow usage of \lsystem processing library independently.
And finally test project is separated to be possible to test all projects independently.
Dependencies of projects in solution are shown in the \autoref{fig:solutionDependencies}.
The \emph{Malsys.Tests} project is not in the diagram because it has dependencies to all projects.

\begin{figure}[h]
	\centering
	\begin{tikzpicture}[node distance=1cm,>=latex]
		\node (c) [block] {Malsys.Common};
		\node (m) [block, below=of c] {Malsys};
		\node (a) [block, right=of m] {Malsys.Ast};
		\node (p) [blockx, right=of a] {Malsys.Parsing};
		\node (w) [block, left=of m] {Malsys.Web};
		\node (cSharp) [block, minimum width=1em, minimum height=1em, above=1cm of p] {C\#};
		\node (fSharp) [blockx, minimum width=1em, minimum height=1em, right=0.5cm of cSharp] {F\#};
		
		\draw [->] (a) edge node {} (c);
		
		\draw [->] (p) edge[bend right=10] node {} (c);
		\draw [->] (p) edge node {} (a);
		
		\draw [->] (m) edge node {} (c);
		\draw [->] (m) edge[bend right] node {} (p);
		\draw [->] (m) edge node {} (a);
		
		\draw [->] (w) edge[bend left=20] node {} (c);
		\draw [->] (w) edge node {} (m);
		\draw [->] (w) edge[bend right] node {} (a);
	\end{tikzpicture}
	\caption{Dependencies of projects in solution}
	\label{fig:solutionDependencies}
\end{figure}


\section{Input parsing}

Input parsing is in the \emph{Malsys.parsing} project and it have two phases, lexing and parsing.
Lexing phase uses the lexer to convert input source codes to stream of \emph{tokens} (basic blocks of input) from which the parser parses the abstract syntax tree (AST).
The lexer is generated by the \emph{FsLex} tool [\ref{sec:FSharpPowerPack}].
Rules for the \emph{FsLex} are written using regular expressions and F\# code.
\autoref{code:fsl} shows an example of lexer definition of the \emph{FsLex} tool.
Full definition is in the file \emph{Lexer.fsl} in the \emph{Malsys.parsing} project.

\begin{Fsharp}[label=code:fsl,caption={Example of definition file for \emph{FsLex}}]
let whitespace = [' ' '\t']
let digit = '\Nd'  // unicode group for digits
// uppercase, lowercase, titlecase, modifier, other, number (letter)
let letter = '\Lu' | '\Ll' | '\Lt' | '\Lm' | '\Lo' | '\Nl'
// punctuation (connector), nonspacing, spacing, other (format)
let specialChar = '\Pc' | '\Mn' | '\Mc' | '\Cf'
let idFirstChar = letter | '_'
let idChar = letter | specialChar | digit | ['\'']
let id = idFirstChar idChar*

rule tokenize args = parse
    | whitespace { tokenize args lexbuf }  // ignore whitespaces
    | id { match keywords.TryFind(lexeme lexbuf) with
        | Some(token) -> token  // keyword
        | None -> ID(lexeme lexbuf) }  // identifier
    | digit+ { parseInt args lexbuf ConstantFormat.Float }
    ...
\end{Fsharp}

After lexing comes parsing.
Parser is generated by \emph{FsYacc} tool [\ref{sec:FSharpPowerPack}] from definition file (\emph{Parser.fsy} in the \emph{Malsys.parsing} project).
\autoref{code:fsl} shows an example of parser definition.

\begin{Fsharp}[label=code:fsy,caption={Example of definition file for \emph{FsYacc}}]
// constant definition
ConstDef:
    | LET Id EQUALS Expression SEMI
      { new ConstantDefinition($2, $4, getPos parseState) }
 // function definition     
FunDef:
    | FUN Id OptParamsParens FunBody
      { new FunctionDefinition($2, $3, $4, getPos parseState) }
FunBody:
    | LBRACE FunStatementsList RBRACE
      { new ImmutableListPos<IFunctionStatement>(
      		$2, getPos parseState) }
FunStatementsList:
    |
      { new ResizeArray<IFunctionStatement>() }
    | FunStatementsList FunStatement
      { $1.Add($2); $1 }
FunStatement:
    | ConstDef
      { $1 :> IFunctionStatement }
    | RETURN Expression SEMI
      { $2 :> IFunctionStatement }
// identifier
Id:
    | ID
      { new Identificator($1, getPos parseState) }
\end{Fsharp}






















