
//------------------------------------------------------------------------------
// Header of parser file.
//------------------------------------------------------------------------------

%{

open System
open Microsoft.FSharp.Text.Parsing

open MessagesLogger
open Malsys
open Malsys.Ast
open Malsys.Compilers



// This function is called by the generated parser code. Returning initiates error recovery.
// Saves last error position to thread-static messages logger.
let parse_error_rich = Some (fun (ctxt: ParseErrorContext<_>) ->
   MessagesLogger.setErrPos (new Position(ctxt.ParseState.ResultRange))  )


let getLastErrorPos = MessagesLogger.getLastErrPos


let logError parserState msg =
    MessagesLogger.logMessage CompilerMessageType.Error parserState msg

let logNoticePos pos msg =
    MessagesLogger.logMessagePos CompilerMessageType.Notice pos msg

let logErrorPos pos msg =
    MessagesLogger.logMessagePos CompilerMessageType.Error pos msg


let getPos (parserState : IParseState) =
    new Position(parserState.ResultRange)

let getPosI (parserState : IParseState) index =
    new Position(parserState.InputRange(index))

let getPosRange (parserState : IParseState) fromI toI =
    new Position((fst (parserState.InputRange(fromI)), snd (parserState.InputRange(toI))))

let getPosFromTo (fromPos : Position) (toPos : Position) =
    new Position(fromPos.BeginLine, fromPos.BeginColumn, toPos.BeginLine, toPos.BeginColumn)

let getPosBetween (parserState : IParseState) fromI toI =
    new Position((snd (parserState.InputRange(fromI)), fst (parserState.InputRange(toI))))

let getStartPos (parserState : IParseState) =
    let startPos = fst parserState.ResultRange
    new Position(startPos, startPos)

let getEndPos (parserState : IParseState) =
    let endPos = snd parserState.ResultRange
    new Position(endPos, endPos)


let optionToStatement parseState (option : Option<#ILsystemStatement>) =
    match option with
        | Some(value) -> value
        | None -> new EmptyStatement(getPos parseState, true) :> ILsystemStatement

type SymbolsListPos_Expression = SymbolsListPos<Expression>

%}


//------------------------------------------------------------------------------
// Tokens lists.
//------------------------------------------------------------------------------

%token <string> ID
%token <Keyword> LSYSTEM REWRITE WITH WHERE TO OR WEIGHT NOTHING CONSIDER LET SET FUN RETURN
%token EQUALS SEMI COMMA QMARK COLON RARROW
%token LPAREN RPAREN LBRACE RBRACE LBRACK RBRACK
%token <float * ConstantFormat> FLOAT
%token <string> OPERATOR
%token EOF


//------------------------------------------------------------------------------
// Priorities of tokens
//------------------------------------------------------------------------------

// ID . LPAREN -> ExprFunc (not ExprMember ExprParen)
%nonassoc ID
%nonassoc LPAREN


//------------------------------------------------------------------------------
// Start (enter) rules and types.
//------------------------------------------------------------------------------

%start ParseLsystemStatements
%type <InputBlock> ParseLsystemStatements

%start ParseExprInteractiveStatements
%type <IExprInteractiveStatement[]> ParseExprInteractiveStatements


%start ParseLsystem
%type <Lsystem> ParseLsystem

%start ParseVarDef
%type <VariableDefinition> ParseVarDef

%start ParseFunDef
%type <FunctionDefinition> ParseFunDef

%start ParseSymbols
%type <SymbolsListPos_Expression> ParseSymbols

%start ParseExpression
%type <Expression> ParseExpression

%%


//------------------------------------------------------------------------------
// Start rules.
//------------------------------------------------------------------------------

ParseLsystemStatements:
    | LsystemStatementsList EOF
      { new InputBlock($1 :> ResizeArray<IInputStatement>) }

ParseExprInteractiveStatements:
    | ExprInteractiveStatementList EOF
      { ($1 :> ResizeArray<IExprInteractiveStatement>).ToArray() }
    | error EOF
      { logErrorPos getLastErrorPos "Syntax error.";
        Array.empty<IExprInteractiveStatement> }


ParseLsystem:
    | MaybeLsystem EOF
      { match $1 with
        | Some(lsys) -> lsys
        | None -> null }
    | error EOF
      { logErrorPos getLastErrorPos "Syntax error.";
        null }

ParseVarDef:
    | MaybeVarDef EOF
      { match $1 with
        | Some(varDef) -> varDef
        | None -> null }
    | error EOF
      { logErrorPos getLastErrorPos "Syntax error.";
        null }

ParseFunDef:
    | MaybeFunDef EOF
      { match $1 with
        | Some(funDef) -> funDef
        | None -> null }
    | error EOF
      { logErrorPos getLastErrorPos "Syntax error.";
        null }


ParseSymbols:
    | SymbolWithArgsList EOF
      { $1 }
    | error EOF
      { logErrorPos getLastErrorPos "Syntax error.";
        new SymbolsListPos<Expression>(getStartPos parseState) }


ParseExpression:
    | Expression EOF
      { $1 }
    | error EOF
      { logErrorPos getLastErrorPos "Syntax error.";
        new Expression(getStartPos parseState) }


//------------------------------------------------------------------------------
// Lsystem input.
//------------------------------------------------------------------------------

LsystemStatementsList:
    |
      { new ResizeArray<IInputStatement>() }
    | LsystemStatementsList LsystemStatement
      { $1.Add($2); $1 }

LsystemStatement:
    | MaybeLsystem
      { match $1 with
        | Some(lsys) -> lsys :> IInputStatement
        | None -> new EmptyStatement(getPos parseState, true) :> IInputStatement }
    | MaybeVarDef
      { match $1 with
        | Some(varDef) -> varDef :> IInputStatement
        | None -> new EmptyStatement(getPos parseState, true) :> IInputStatement }
    | MaybeFunDef
      { match $1 with
        | Some(funDef) -> funDef :> IInputStatement
        | None -> new EmptyStatement(getPos parseState, true) :> IInputStatement }
    | SEMI
      { new EmptyStatement(getPos parseState) :> IInputStatement }
    | error
      { logErrorPos getLastErrorPos "Excpected input statement (L-Sysytem, variable or function definition).";
        new EmptyStatement(ThreadStatic.LasErrorPos, true) :> IInputStatement }


//------------------------------------------------------------------------------
// Expression interactive input.
//------------------------------------------------------------------------------

ExprInteractiveStatementList:
    |
      { new ResizeArray<IExprInteractiveStatement>() }
    | ExprInteractiveStatementList ExprInteractiveStatement
      { $1.Add($2); $1 }
    | ExprInteractiveStatementList SEMI
      { $1 }

ExprInteractiveStatement:
    | ExpressionNonEmpty SEMI
      { $1 :> IExprInteractiveStatement }
    | MaybeVarDef
      { match $1 with
        | Some(varDef) -> varDef :> IExprInteractiveStatement
        | None -> new EmptyStatement(getPos parseState, true) :> IExprInteractiveStatement }
    | MaybeFunDef
      { match $1 with
        | Some(funDef) -> funDef :> IExprInteractiveStatement
        | None -> new EmptyStatement(getPos parseState, true) :> IExprInteractiveStatement }


//------------------------------------------------------------------------------
// Variable definition.
//------------------------------------------------------------------------------

MaybeVarDef:
    | LET ID EQUALS Expression SEMI
      { let kw = new KeywordPos($1, getPosI parseState 1) in
        let id = new Identificator($2, getPosI parseState 2) in
        Some (new VariableDefinition(kw, id, $4, getPos parseState)) }
    | LET EQUALS Expression SEMI
      { logErrorPos (getPosBetween parseState 1 3) "Variable name excpected.";
        None }
    | LET error EQUALS Expression SEMI
      { logErrorPos (getPosBetween parseState 1 3) "Variable name excpected.";
        None }
    | LET error SEMI
      { logErrorPos (getPosBetween parseState 1 3) "Variable definition excpected.";
        None }

VarDefsList:
    |
      { new ImmutableListPos<VariableDefinition>(getPos parseState) }
    | VarDefsListNonEmpty
      { new ImmutableListPos<VariableDefinition>($1 :> ResizeArray<VariableDefinition>, getPos parseState) }

VarDefsListNonEmpty:
    | MaybeVarDef
      { let mutable x = new ResizeArray<VariableDefinition>() in
        match $1 with
        | Some(varDef) -> x.Add(varDef); x
        | None -> x }
    | VarDefsListNonEmpty MaybeVarDef
      { match $2 with
        | Some(varDef) -> $1.Add(varDef); $1
        | None -> $1 }


//------------------------------------------------------------------------------
// Function definition.
//------------------------------------------------------------------------------

MaybeFunDef:
    | FUN ID FunDefParams FunBody
      { let kw = new KeywordPos($1, getPosI parseState 1) in
        let id = new Identificator($2, getPosI parseState 2) in
        let (retKw, vars, expr) = $4 in
        let keywords = KeywordPos.CreateListKnownOnly(kw, retKw) in
        Some (new FunctionDefinition(id, $3, vars, expr, keywords, getPos parseState)) }
    | FUN ID error FunBody
      { logErrorPos (getPosBetween parseState 2 4) "Function parameters excpected.";
        None }

FunDefParams:
    | LPAREN OptParamsList RPAREN
      { new ImmutableListPos<OptionalParameter>($2 :> ResizeArray<OptionalParameter>, getPosI parseState 1, getPosI parseState 3, getPos parseState) }
    | LPAREN error RPAREN
      { logErrorPos (getPosBetween parseState 1 3) "Excpected parameters with optional default value separated by comma.";
        new ImmutableListPos<OptionalParameter>(getPos parseState) }

FunBody:
    | LBRACE VarDefsList RETURN Expression SEMI RBRACE
      { let kw = new KeywordPos($3, getPosI parseState 3) in
        let vars = $2.AddSeparators(getPosI parseState 1, getPosI parseState 6) in
        (kw, vars, $4) }
    | LBRACE error RBRACE
      { logErrorPos (getPosBetween parseState 1 3) "Excpected function body.";
        let vars = new ImmutableListPos<VariableDefinition>(getPosI parseState 1, getPosI parseState 3, getPos parseState) in
        (KeywordPos.Unknown, vars, Expression.Empty) }

OptParamsList:
    |
      { new ResizeArray<OptionalParameter>() }
    | OptParamsListNonEmpty
      { $1 }

OptParamsListNonEmpty:
    | OptParam
      { let mutable x = new ResizeArray<OptionalParameter>() in x.Add($1); x }
    | OptParamsListNonEmpty COMMA OptParam
      { $1.Add($3); $1 }

OptParam:
    | ID
      { let id = new Identificator($1, getPosI parseState 1) in
        new OptionalParameter(id, getPos parseState) }
    | ID EQUALS Expression
      { let id = new Identificator($1, getPosI parseState 1) in
        new OptionalParameter(id, $3, getPos parseState) }


//------------------------------------------------------------------------------
// L-system definition.
//------------------------------------------------------------------------------

MaybeLsystem:
    | LSYSTEM ID OptFunDefParams LsystemBody
      { let kw = new KeywordPos($1, getPosI parseState 1) in
        let id = new Identificator($2, getPosI parseState 2) in
        Some (new Lsystem(kw, id, $3, $4, getPos parseState)) }
    | LSYSTEM error LsystemBody
      { logErrorPos (getPosBetween parseState 1 3) "Lsystem name and params excpected.";
        None }

OptFunDefParams:
    |
      { new ImmutableListPos<OptionalParameter>(getStartPos parseState) }
    | FunDefParams
      { $1 }

LsystemBody:
    | LBRACE LsysStatementsList RBRACE
      { new ImmutableListPos<ILsystemStatement>($2 :> ResizeArray<ILsystemStatement>, getPosI parseState 1, getPosI parseState 3, getPos parseState)  }

LsysStatementsList:
    |
      { new ResizeArray<ILsystemStatement>() }
    | LsysStatementsList LsysStatement
      { $1.Add($2); $1 }

LsysStatement:
    | MaybeRewriteRule
      { match $1 with
        | Some(rr) -> rr :> ILsystemStatement
        | None -> new EmptyStatement(getPos parseState, true) :> ILsystemStatement }
    | MaybeVarDef
      { match $1 with
        | Some(varDef) -> varDef :> ILsystemStatement
        | None -> new EmptyStatement(getPos parseState, true) :> ILsystemStatement }
    | MaybeSymbolsDef
      { match $1 with
        | Some(symDef) -> symDef :> ILsystemStatement
        | None -> new EmptyStatement(getPos parseState, true) :> ILsystemStatement }
    | MaybeFunDef
      { match $1 with
        | Some(funDef) -> funDef :> ILsystemStatement
        | None -> new EmptyStatement(getPos parseState, true) :> ILsystemStatement }
    | SEMI
      { new EmptyStatement(getPos parseState) :> ILsystemStatement }
    | error
      { logErrorPos getLastErrorPos "Excpected L-System statement.";
        new EmptyStatement(ThreadStatic.LasErrorPos, true) :> ILsystemStatement }

MaybeSymbolsDef:
    | SET ID EQUALS SymbolWithArgsList SEMI
      { let kw = new KeywordPos($1, getPosI parseState 1) in
        let id = new Identificator($2, getPosI parseState 2) in
        Some (new SymbolsDefinition(kw, id, $4, getPos parseState)) }
    | SET EQUALS SymbolWithArgsList SEMI
      { logErrorPos (getPosBetween parseState 1 3) "Symbols name excpected.";
        None }
    | SET error EQUALS SymbolWithArgsList SEMI
      { logErrorPos (getPosBetween parseState 1 3) "Symbols name excpected.";
        None }
    | SET error SEMI
      { logErrorPos (getPosBetween parseState 1 3) "Symbols definition excpected.";
        None }


//------------------------------------------------------------------------------
// L-system's rewrite rule.
//------------------------------------------------------------------------------

MaybeRewriteRule:
    | REWRITE RrPattern OptRrVarDefs OptRrCondition TO RrReplacListNonEmpty SEMI
      { let rwKw = new KeywordPos($1, getPosI parseState 1) in
        let (lCtxt, patt, rCtxt) = $2 in
        let (vdKw, vds) = $3 in
        let (cKw, cond) = $4 in
        let toKw = new KeywordPos($5, getPosI parseState 5) in
        let replac = new ImmutableListPos<RewriteRuleReplacement>($6 :> ResizeArray<RewriteRuleReplacement>, getPosI parseState 6) in
        let keywords = KeywordPos.CreateListKnownOnly(rwKw, vdKw, cKw, toKw) in
        Some (new RewriteRule(patt, lCtxt, rCtxt, vds, cond, replac, keywords, getPos parseState)) }
    | REWRITE error SEMI
      { logErrorPos (getPosBetween parseState 1 3) "Excpected rewrite rule.";
        None }

RrPattern:
    | OptRrCtxt SymbolPattern OptRrCtxt
      { ($1, $2, $3) }
    | error
      { logErrorPos (getPos parseState) "Excpected Rewrite rule pattern.";
        let sList = new SymbolsListPos<Identificator>(Position.Unknown) in
        let sym = new Symbol<Identificator>(null, Position.Unknown) in
        (sList, sym, sList)}

OptRrVarDefs:
    |
      { let vds = new ImmutableListPos<VariableDefinition>(getStartPos parseState) in
        (KeywordPos.Unknown, vds) }
    | WITH
      { logNoticePos (getPosI parseState 1) "Empty variable definition block found.";
        let kw = new KeywordPos($1, getPosI parseState 1) in
        let vds = ImmutableListPos<VariableDefinition>(getStartPos parseState) in
        (kw, vds) }
    | WITH RrVarDefsListNonEmpty
      { let kw = new KeywordPos($1, getPosI parseState 1) in
        let vds = new ImmutableListPos<VariableDefinition>($2 :> ResizeArray<VariableDefinition>, getPos parseState) in
        (kw, vds) }
    | WITH error
      { logError parseState "Excpected variable definitions separated by colon.";
        let kw = new KeywordPos($1, getPosI parseState 1) in
        let vds = ImmutableListPos<VariableDefinition>(getStartPos parseState) in
        (kw, vds) }

OptRrCondition:
    |
      { let expr = new Expression(getStartPos parseState) in
        (KeywordPos.Unknown, expr) }
    | WHERE
      { logNoticePos (getPosI parseState 1) "Empty condition found.";
        let kw = new KeywordPos($1, getPosI parseState 1) in
        (kw, new Expression(getEndPos parseState)) }
    | WHERE ExpressionNonEmpty
      { let kw = new KeywordPos($1, getPosI parseState 1) in
        (kw, $2) }
    | WHERE error
      { logError parseState "Excpected condition expression.";
        let kw = new KeywordPos($1, getPosI parseState 1) in
        (kw, new Expression(getEndPos parseState)) }

RrReplacListNonEmpty:
    | RrReplac
      { let mutable x = new ResizeArray<RewriteRuleReplacement>() in x.Add($1); x }
    | RrReplacListNonEmpty RrReplacOrTo
      { $1.Add($2); $1 }

RrReplac:
    | RrReplacSymbols OptRrWeight
      { let (rKw, replac) = $1 in
        let (wKw, weight) = $2 in
        let keywords = KeywordPos.CreateListKnownOnly(rKw, wKw) in
        new RewriteRuleReplacement(replac, weight, keywords, getPos parseState) }

RrReplacOrTo:
    | OR TO RrReplacSymbols OptRrWeight
      { let orKw = new KeywordPos($1, getPosI parseState 1) in
        let toKw = new KeywordPos($2, getPosI parseState 2) in
        let (rKw, replac) = $3 in
        let (wKw, weight) = $4 in
        let keywords = KeywordPos.CreateListKnownOnly(orKw, toKw, rKw, wKw) in
        new RewriteRuleReplacement(replac, weight, keywords, getPos parseState) }

RrReplacSymbols:
    | NOTHING
      { let kw = new KeywordPos($1, getPosI parseState 1) in
        let list = new SymbolsListPos<Expression>(getPos parseState) in
        (kw, list)}
    | SymbolWithArgsList
      { if $1.Length = 0 then logNoticePos (getStartPos parseState) "Empty replacement block found, you can use keyword `nothing` to improve source code readability." else ();
        (KeywordPos.Unknown, $1) }

OptRrWeight:
    |
      { let expr = new Expression(getStartPos parseState) in
        (KeywordPos.Unknown, expr) }
    | WEIGHT
      { logNoticePos (getPosI parseState 1) "Empty probability weight found.";
        let kw = new KeywordPos($1, getPosI parseState 1) in
        (kw, new Expression(getEndPos parseState)) }
    | WEIGHT ExpressionNonEmpty
      { let kw = new KeywordPos($1, getPosI parseState 1) in
        (kw, $2) }
    | WEIGHT error
      { logError parseState "Excpected probability weight (expression).";
        let kw = new KeywordPos($1, getPosI parseState 1) in
        (kw, new Expression(getEndPos parseState)) }


OptRrCtxt:
    |
      { new SymbolsListPos<Identificator>(getStartPos parseState) }
    | LBRACE SymbolPatternsList RBRACE
      { new SymbolsListPos<Identificator>($2, getPosI parseState 1, getPosI parseState 3, getPos parseState) }
    | LBRACE error RBRACE
      { logErrorPos (getPosBetween parseState 1 3) "Excpected symbol patterns as context.";
        new SymbolsListPos<Identificator>(getPosI parseState 1, getPosI parseState 3, getPos parseState) }

RrVarDef:
    | ID EQUALS Expression
      { let id = new Identificator($1, getPosI parseState 1) in
        new VariableDefinition(KeywordPos.Unknown, id, $3, getPos parseState) }

RrVarDefsListNonEmpty:
    | RrVarDef
      { let mutable x = new ResizeArray<VariableDefinition>() in x.Add($1); x }
    | RrVarDefsListNonEmpty COMMA RrVarDef
      { $1.Add($3); $1 }


//------------------------------------------------------------------------------
// L-system's symbols (modules).
//------------------------------------------------------------------------------

SymbolPattern:
    | Symbol
      { new Symbol<Identificator>($1, getPos parseState) }
    | Symbol LPAREN IdsCommaList RPAREN
      { let args = ($3 :> ImmutableListPos<Identificator>).AddSeparators(getPosI parseState 2, getPosI parseState 4)
        new Symbol<Identificator>($1, args, getPos parseState) }

SymbolPatternsList:
    |
      { new ResizeArray<Symbol<Identificator>>() }
    | SymbolPatternsList SymbolPattern
      { $1.Add($2); $1 }

SymbolWithArgs:
    | Symbol
      { new Symbol<Expression>($1, getPos parseState) }
    | Symbol LPAREN ExpressionsList RPAREN
      { let args = ($3 :> ImmutableListPos<Expression>).AddSeparators(getPosI parseState 2, getPosI parseState 4)
        new Symbol<Expression>($1, args, getPos parseState) }

SymbolWithArgsList:
    |
      { new SymbolsListPos<Expression>(getStartPos parseState) }
    | SymbolWithArgsListNonEmpty
      { new SymbolsListPos<Expression>($1 :> System.Collections.Generic.IEnumerable<Symbol<Expression>>, getPos parseState) }

SymbolWithArgsListNonEmpty:
    | SymbolWithArgs
      { let mutable x = new ResizeArray<Symbol<Expression>>() in x.Add($1); x }
    | SymbolWithArgsListNonEmpty SymbolWithArgs
      { $1.Add($2); $1 }

Symbol:
    | ID
      { $1 }
    | OPERATOR
      { $1 }


//------------------------------------------------------------------------------
// Expressions.
//------------------------------------------------------------------------------

Expression:
    |
      { logError parseState "Excpected non-empty expression.";
        new Expression(getStartPos parseState) }
    | ExpressionMembersNonEmpty
      { new Expression($1, getPos parseState) }

ExpressionNonEmpty:
    | ExpressionMembersNonEmpty
      { new Expression($1, getPos parseState) }

ExpressionMembersNonEmpty:
    | ExprMember
      { let mutable x = new ResizeArray<IExpressionMember>() in x.Add($1); x }
    | ExpressionMembersNonEmpty ExprMember
      { $1.Add($2); $1 }

ExprMember:
    | FLOAT
      { let (value, fmt) = $1 in
        new FloatConstant(value, fmt, getPos parseState) :> IExpressionMember }
    | ID
      { new Identificator($1, getPos parseState) :> IExpressionMember }
    | ExpressionsArray
      { $1 :> IExpressionMember }
    | OPERATOR
      { new Operator($1, getPos parseState) :> IExpressionMember }
    | ExprIndexer
      { $1 :> IExpressionMember }
    | ExprFun
      { $1 :> IExpressionMember }
    | ExprParen
      { $1 :> IExpressionMember }


ExpressionsArray:
    | LBRACE ExpressionsList RBRACE
      { new ExpressionsArray($2, getPosI parseState 1, getPosI parseState 3) }
    | LBRACE error RBRACE
      { logErrorPos (getPosBetween parseState 1 3) "Excpected expressions separated by comma.";
        new ExpressionsArray(getPos parseState) }

ExpressionsList:
    |
      { new ImmutableListPos<Expression>(getPos parseState) }
    | ExpressionsListNonEmpty
      { new ImmutableListPos<Expression>($1 :> ResizeArray<Expression>, getPos parseState) }

ExpressionsListNonEmpty:
    | ExpressionNonEmpty
      { let mutable x = new ResizeArray<Expression>() in x.Add($1); x }
    | ExpressionsListNonEmpty COMMA Expression
      { $1.Add($3); $1 }
    | ExpressionsListNonEmpty COMMA error
      { logErrorPos (getPosFromTo (getPosI parseState 2) (getPos parseState)) "Invalid expression in array.";
        $1 }

ExprIndexer:
    | LBRACK Expression RBRACK
      { new ExpressionIndexer($2, getPos parseState) }

ExprFun:
    | ID LPAREN ExpressionsList RPAREN
      { let id = new Identificator($1, getPosI parseState 1) in
        let args = $3.AddSeparators(getPosI parseState 2, getPosI parseState 4)
        new ExpressionFunction(id, args, getPos parseState) :> IExpressionMember }

ExprParen:
    | LPAREN Expression RPAREN
      { new ExpressionBracketed($2, getPos parseState) }


//------------------------------------------------------------------------------
// Other.
//------------------------------------------------------------------------------

IdsCommaList:
    |
      { new ImmutableListPos<Identificator>(getPos parseState) }
    | IdsCommaListNonEmpty
      { new ImmutableListPos<Identificator>($1 :> ResizeArray<Identificator>, getPos parseState) }

IdsCommaListNonEmpty:
    | ID
      { let id = new Identificator($1, getPos parseState) in
        let mutable x = new ResizeArray<Identificator>() in
        x.Add(id);
        x }
    | IdsCommaListNonEmpty COMMA ID
      { let id = new Identificator($3, getPosI parseState 3) in
        $1.Add(id);
        $1 }