%{

open System
open Microsoft.FSharp.Text.Parsing

open MessagesLogger
open Malsys
open Malsys.Ast
open Malsys.Compilers


let logError parserState msg =
    MessagesLogger.logMessage CompilerMessageType.Error parserState msg

let logErrorPos pos msg =
    MessagesLogger.logMessagePos CompilerMessageType.Error pos msg

let logErrorLastPos msg =
    MessagesLogger.logMessageLastPos CompilerMessageType.Error msg

let getLastErrorPos =
    MessagesLogger.getLastErrPos


// This function is called by the generated parser code. Returning initiates error recovery.
// Saves last error position to thread-static messages logger
let parse_error_rich = Some (fun (ctxt: ParseErrorContext<_>) ->
   MessagesLogger.setErrPos (new Position(ctxt.ParseState.ResultRange))  )

let toPos (parserState : IParseState) =
    new Position(parserState.ResultRange)

let toPosI (parserState : IParseState) index =
    new Position(parserState.InputRange(index))

let getRangePos (parserState : IParseState) fromI toI =
    new Position((snd (parserState.InputRange(fromI)), fst (parserState.InputRange(toI))))

let toStartPos (parserState : IParseState) =
    let startPos = fst parserState.ResultRange
    new Position(startPos, startPos)

//let getLexbuf (parseState : IParseState) =
//    parseState.ParserLocalStore["LexBuffer"] :?> LexBuffer<_>

%}

%token <string> ID
%token LSYSTEM LET FUN
%token EQUALS SEMI COMMA QMARK COLON RARROW
%token LPAREN RPAREN LBRACE RBRACE LBRACK RBRACK
%token <float> FLOAT
%token <string> OPERATOR
%token EOF


%start parseLsystemStatements
%type <InputBlock> parseLsystemStatements

%start parseExpression
%type <Expression> parseExpression

%start parseExprInteractiveStatements
%type <IExprInteractiveStatement[]> parseExprInteractiveStatements

%%

//------------------------------------------------------------------------------
// Start rules
//------------------------------------------------------------------------------

parseLsystemStatements:
    | LsystemStatementsList EOF
      { new InputBlock($1 :> ResizeArray<IInputStatement>) }
    | error EOF
      { logErrorLastPos "Syntax error.";
        new InputBlock() }

parseExpression:
    | Expression EOF
      { $1 }

parseExprInteractiveStatements:
    | ExprInteractiveStatementList EOF
      { ($1 :> ResizeArray<IExprInteractiveStatement>).ToArray() }


//------------------------------------------------------------------------------
// Lsystem input
//------------------------------------------------------------------------------

LsystemStatementsList:
    |
      { new ResizeArray<IInputStatement>() }
    | LsystemStatementsList LsystemStatement
      { $1.Add($2); $1 }

LsystemStatement:
    | Lsystem
      { $1 :> IInputStatement }
    | MaybeVarDef SEMI
      { match $1 with
        | Some(varDef) -> varDef :> IInputStatement
        | None -> new EmptyStatement(toPos parseState, true) :> IInputStatement }
    | MaybeFunDef
      { match $1 with
        | Some(funDef) -> funDef :> IInputStatement
        | None -> new EmptyStatement(toPos parseState, true) :> IInputStatement }
    | SEMI
      { new EmptyStatement(toPos parseState) :> IInputStatement }


//------------------------------------------------------------------------------
// Expression interactive input
//------------------------------------------------------------------------------

ExprInteractiveStatementList:
    |
      { new ResizeArray<IExprInteractiveStatement>() }
    | ExprInteractiveStatementList ExprInteractiveStatement
      { $1.Add($2); $1 }
    | ExprInteractiveStatementList SEMI
      { $1 }

ExprInteractiveStatement:
    | Expression SEMI
      { $1 :> IExprInteractiveStatement }
    | MaybeVarDef SEMI
      { match $1 with
        | Some(varDef) -> varDef :> IExprInteractiveStatement
        | None -> new EmptyStatement(toPos parseState, true) :> IExprInteractiveStatement }
    | MaybeFunDef
      { match $1 with
        | Some(funDef) -> funDef :> IExprInteractiveStatement
        | None -> new EmptyStatement(toPos parseState, true) :> IExprInteractiveStatement }


//------------------------------------------------------------------------------
// Variable definition
//------------------------------------------------------------------------------

MaybeVarDef:
    | LET Id EQUALS Expression
      { let kw = new Keyword(toPosI parseState 1) in
        Some (new VariableDefinition(kw, $2, $4, toPos parseState)) }
    | LET EQUALS Expression
      { logErrorPos (getRangePos parseState 1 3) "Variable name excpected.";
        None }
    | LET error EQUALS Expression
      { logErrorPos (getRangePos parseState 1 3) "Variable name excpected.";
        None }

// Empty OR variable definitions divided by semicolon (but no semicolon on the end)
VarDefsList:
    |
      { new ResizeArray<VariableDefinition>() }
    | VarDefsListNonEmpty
      { $1 }

// Empty OR variable definitions divided by semicolon with extra semicolon on the end
VarDefsListSemi:
    |
      { new ResizeArray<VariableDefinition>() }
    | VarDefsListNonEmpty SEMI
      { $1 }

VarDefsListNonEmpty:
    | MaybeVarDef
      { let mutable x = new ResizeArray<VariableDefinition>() in
        match $1 with
        | Some(varDef) -> x.Add(varDef); x
        | None -> x }
    | VarDefsListNonEmpty SEMI MaybeVarDef
      { match $3 with
        | Some(varDef) -> $1.Add(varDef); $1
        | None -> $1 }


//------------------------------------------------------------------------------
// Function definition
//------------------------------------------------------------------------------

MaybeFunDef:
    | FUN Id FunDefParams RichExpressionBraces
      { let kw = new Keyword(toPosI parseState 1) in
        Some (new FunctionDefinition(kw, $2, $3, $4, toPos parseState)) }
    | FUN error RichExpressionBraces
      { logErrorPos (getRangePos parseState 1 3) "Function identifier with parameters excpected.";
        None }


MaybeFunDefParams:
    |
      { new ImmutableListPos<OptionalParameter>(toStartPos parseState) }
    | FunDefParams
      { $1 }

FunDefParams:
    | LPAREN OptParamsList RPAREN
      { new ImmutableListPos<OptionalParameter>($2, toPos parseState) }
    | LPAREN error RPAREN
      { logErrorPos (getRangePos parseState 1 3) "Excpected parameters with optional default value separated by comma.";
        new ImmutableListPos<OptionalParameter>(toPos parseState) }

RichExpressionBraces:
    | LBRACE VarDefsListSemi Expression RBRACE
      { new RichExpression($2, $3, toPos parseState) }
    | LBRACE error RBRACE
      { logErrorPos (getRangePos parseState 1 3) "Excpected expression with optional local variable definitions before it divided by semicolon.";
        new RichExpression(toPos parseState) }


OptParamsList:
    |
      { new ResizeArray<OptionalParameter>() }
    | OptParamsListNonEmpty
      { $1 }

OptParamsListNonEmpty:
    | OptParam
      { let mutable x = new ResizeArray<OptionalParameter>() in x.Add($1); x }
    | OptParamsListNonEmpty COMMA OptParam
      { $1.Add($3); $1 }

OptParam:
    | Id
      { new OptionalParameter($1, toPos parseState) }
    | Id EQUALS Expression
      { new OptionalParameter($1, $3, toPos parseState) }


//------------------------------------------------------------------------------
// L-system definition
//------------------------------------------------------------------------------

Lsystem:
    | LSYSTEM Id MaybeFunDefParams LBRACE LsysStatementsList RBRACE
      { let kw = new Keyword(toPosI parseState 1) in
        new Lsystem(kw, $2, $3, $5, toPos parseState) }

LsysStatementsList:
    |
      { new ResizeArray<ILsystemStatement>() }
    | LsysStatementsList LsysStatement
      { $1.Add($2); $1 }

LsysStatement:
    | RewriteRule SEMI
      { $1 :> ILsystemStatement }
    | MaybeVarDef SEMI
      { match $1 with
        | Some(varDef) -> varDef :> ILsystemStatement
        | None -> new EmptyStatement(toPos parseState, true) :> ILsystemStatement }
    | MaybeFunDef
      { match $1 with
        | Some(funDef) -> funDef :> ILsystemStatement
        | None -> new EmptyStatement(toPos parseState, true) :> ILsystemStatement }
    | SEMI
      { new EmptyStatement(toPos parseState) :> ILsystemStatement }
    | error
      { logErrorLastPos "Excpected L-System statement.";
        new EmptyStatement(ThreadStatic.LasErrorPos, true) :> ILsystemStatement }


//------------------------------------------------------------------------------
// L-system's rewrite rule
//------------------------------------------------------------------------------

RewriteRule:
    | MaybeCtxt SymbolPattern MaybeCtxt MaybeCondition MaybeProbab RARROW MaybeVarDefs SymbolWithArgsList
      { new RewriteRule($2, $1, $3, $4, $5, $7, $8, toPos parseState) }

MaybeCtxt:
    |
      { new ImmutableListPos<SymbolPattern>(toStartPos parseState) }
    | LBRACE SymbolPatternsList RBRACE
      { new ImmutableListPos<SymbolPattern>($2, toPos parseState) }
    | LBRACE error RBRACE
      { logErrorPos (getRangePos parseState 1 3) "Excpected symbol patterns.";
        new ImmutableListPos<SymbolPattern>(toPos parseState) }

MaybeCondition:
    |
      { new RichExpression(toStartPos parseState) }
    | QMARK RichExpressionBraces
      { new RichExpression($2, toPos parseState) }

MaybeProbab:
    |
      { new RichExpression(toStartPos parseState) }
    | COLON RichExpressionBraces
      { new RichExpression($2, toPos parseState) }

MaybeVarDefs:
    |
      { new ImmutableListPos<VariableDefinition>(toStartPos parseState) }
    | LBRACE VarDefsList RBRACE
      { new ImmutableListPos<VariableDefinition>($2, toPos parseState) }
    | LBRACE error RBRACE
      { logErrorPos (getRangePos parseState 1 3) "Excpected variable definitions.";
        new ImmutableListPos<VariableDefinition>(toPos parseState) }


//------------------------------------------------------------------------------
// L-system's symbols (modules)
//------------------------------------------------------------------------------

SymbolPattern:
    | Symbol
      { new SymbolPattern($1, toPos parseState) }
    | Symbol LPAREN IdsCommaList RPAREN
      { new SymbolPattern($1, $3, toPos parseState) }

SymbolPatternsList:
    |
      { new ResizeArray<SymbolPattern>() }
    | SymbolPatternsList SymbolPattern
      { $1.Add($2); $1 }

SymbolWithArgs:
    | Symbol
      { new SymbolExprArgs($1, toPos parseState) }
    | Symbol LPAREN ExpressionsList RPAREN
      { new SymbolExprArgs($1, $3, toPos parseState) }

SymbolWithArgsList:
    |
      { new ResizeArray<SymbolExprArgs>() }
    | SymbolWithArgsList SymbolWithArgs
      { $1.Add($2); $1 }

Symbol:
    | ID
      { new Symbol($1, toPos parseState) }
    | OPERATOR
      { new Symbol($1, toPos parseState) }


//------------------------------------------------------------------------------
// Expressions
//------------------------------------------------------------------------------

Expression:
    |
      { logError parseState "Excpected non-empty expression.";
        new Expression(toStartPos parseState) }
    | ExpressionNonEmpty
      { new Expression($1, toPos parseState) }

ExpressionNonEmpty:
    | ExprMember
      { let mutable x = new ResizeArray<IExpressionMember>() in x.Add($1); x }
    | ExpressionNonEmpty ExprMember
      { $1.Add($2); $1 }

ExprMember:
    | Float
      { $1 :> IExpressionMember }
    | Id
      { $1 :> IExpressionMember }
    | ExpressionsArray
      { $1 :> IExpressionMember }
    | Operator
      { $1 :> IExpressionMember }
    | ExprIndexer
      { $1 :> IExpressionMember }
    | ExprFunc
      { $1 :> IExpressionMember }
    | ExprParen
      { $1 :> IExpressionMember }


ExpressionsArray:
    | LBRACE ExpressionsList RBRACE
      { new ExpressionsArray($2, toPos parseState) }
    | LBRACE error RBRACE
      { logError parseState "Expeted list of expression (divided by comma).";
        new ExpressionsArray(toPos parseState) }

ExpressionsList:
    |
      { new ResizeArray<Expression>() }
    | ExpressionsListNonEmpty
      { $1 }

ExpressionsListNonEmpty:
    | ExpressionNonEmpty
      { let mutable x = new ResizeArray<Expression>() in
        let expr = new Expression($1, toPos parseState) in
        x.Add(expr);
        x }
    | ExpressionsListNonEmpty COMMA Expression
      { $1.Add($3); $1 }

ExprIndexer:
    | LBRACK Expression RBRACK
      { new ExpressionIndexer($2, toPos parseState) }

ExprFunc:
    | Id LPAREN ExpressionsList RPAREN
      { new ExpressionFunction($1, $3, toPos parseState) }

ExprParen:
    | LPAREN Expression RPAREN
      { new ExpressionBracketed($2, toPos parseState) }


//------------------------------------------------------------------------------
// Primitives
//------------------------------------------------------------------------------

Id:
    | ID
      { new Identificator($1, toPos parseState) }

IdsCommaList:
    |
      { new ResizeArray<Identificator>() }
    | IdsCommaListNonEmpty
      { $1 }

IdsCommaListNonEmpty:
    | Id
      { let mutable x = new ResizeArray<Identificator>() in x.Add($1); x }
    | IdsCommaListNonEmpty COMMA Id
      { $1.Add($3); $1 }


Operator:
    | OPERATOR
      { new Operator($1, toPos parseState) }

Float:
    | FLOAT
      { new FloatConstant($1, toPos parseState) }


//------------------------------------------------------------------------------
// Keywords
//------------------------------------------------------------------------------

LsysKw:
    | LSYSTEM
      { new Keyword(toPos parseState) }

LetKw:
    | LET
      { new Keyword(toPos parseState) }

FunKw:
    | FUN
      { new Keyword(toPos parseState) }
