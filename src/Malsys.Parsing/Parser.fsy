%{

open System
open Microsoft.FSharp.Text.Parsing

open MessagesLogger
open Malsys
open Malsys.Ast
open Malsys.Compilers


let logError parserState msg =
    MessagesLogger.logMessage CompilerMessageType.Error parserState msg

let logNoticePos pos msg =
    MessagesLogger.logMessagePos CompilerMessageType.Notice pos msg

let logErrorPos pos msg =
    MessagesLogger.logMessagePos CompilerMessageType.Error pos msg

let logErrorLastPos msg =
    MessagesLogger.logMessageLastPos CompilerMessageType.Error msg

let getLastErrorPos =
    MessagesLogger.getLastErrPos


// This function is called by the generated parser code. Returning initiates error recovery.
// Saves last error position to thread-static messages logger
let parse_error_rich = Some (fun (ctxt: ParseErrorContext<_>) ->
   MessagesLogger.setErrPos (new Position(ctxt.ParseState.ResultRange))  )

let getPos (parserState : IParseState) =
    new Position(parserState.ResultRange)

let getPosI (parserState : IParseState) index =
    new Position(parserState.InputRange(index))

let getRangePos (parserState : IParseState) fromI toI =
    new Position((fst (parserState.InputRange(fromI)), snd (parserState.InputRange(toI))))

let getBetweenPos (parserState : IParseState) fromI toI =
    new Position((snd (parserState.InputRange(fromI)), fst (parserState.InputRange(toI))))

let getStartPos (parserState : IParseState) =
    let startPos = fst parserState.ResultRange
    new Position(startPos, startPos)

let getEndPos (parserState : IParseState) =
    let endPos = snd parserState.ResultRange
    new Position(endPos, endPos)

//let getLexbuf (parseState : IParseState) =
//    parseState.ParserLocalStore["LexBuffer"] :?> LexBuffer<_>

%}

%token <string> ID
// keywords
%token LSYSTEM REWRITE WITH WHERE TO WEIGHT NOTHING CONSIDER LET SET FUN
%token EQUALS SEMI COMMA QMARK COLON RARROW
%token LPAREN RPAREN LBRACE RBRACE LBRACK RBRACK
%token <float> FLOAT
%token <string> OPERATOR
%token EOF


%start parseLsystemStatements
%type <InputBlock> parseLsystemStatements

%start parseExpression
%type <Expression> parseExpression

%start parseExprInteractiveStatements
%type <IExprInteractiveStatement[]> parseExprInteractiveStatements

%%

//------------------------------------------------------------------------------
// Start rules
//------------------------------------------------------------------------------

parseLsystemStatements:
    | LsystemStatementsList EOF
      { new InputBlock($1 :> ResizeArray<IInputStatement>) }
    | error EOF
      { logErrorLastPos "Syntax error.";
        new InputBlock() }

parseExpression:
    | Expression EOF
      { $1 }
    | error EOF
      { logErrorLastPos "Syntax error.";
        new Expression(getStartPos parseState) }

parseExprInteractiveStatements:
    | ExprInteractiveStatementList EOF
      { ($1 :> ResizeArray<IExprInteractiveStatement>).ToArray() }
    | error EOF
      { logErrorLastPos "Syntax error.";
        Array.empty<IExprInteractiveStatement> }


//------------------------------------------------------------------------------
// Lsystem input
//------------------------------------------------------------------------------

LsystemStatementsList:
    |
      { new ResizeArray<IInputStatement>() }
    | LsystemStatementsList LsystemStatement
      { $1.Add($2); $1 }

LsystemStatement:
    | Lsystem
      { $1 :> IInputStatement }
    | MaybeVarDef
      { match $1 with
        | Some(varDef) -> varDef :> IInputStatement
        | None -> new EmptyStatement(getPos parseState, true) :> IInputStatement }
    | MaybeFunDef
      { match $1 with
        | Some(funDef) -> funDef :> IInputStatement
        | None -> new EmptyStatement(getPos parseState, true) :> IInputStatement }
    | SEMI
      { new EmptyStatement(getPos parseState) :> IInputStatement }
    | error
      { logErrorLastPos "Excpected input statement (L-Sysytem, variable or function definition).";
        new EmptyStatement(ThreadStatic.LasErrorPos, true) :> IInputStatement }


//------------------------------------------------------------------------------
// Expression interactive input
//------------------------------------------------------------------------------

ExprInteractiveStatementList:
    |
      { new ResizeArray<IExprInteractiveStatement>() }
    | ExprInteractiveStatementList ExprInteractiveStatement
      { $1.Add($2); $1 }
    | ExprInteractiveStatementList SEMI
      { $1 }

ExprInteractiveStatement:
    | Expression SEMI
      { $1 :> IExprInteractiveStatement }
    | MaybeVarDef
      { match $1 with
        | Some(varDef) -> varDef :> IExprInteractiveStatement
        | None -> new EmptyStatement(getPos parseState, true) :> IExprInteractiveStatement }
    | MaybeFunDef
      { match $1 with
        | Some(funDef) -> funDef :> IExprInteractiveStatement
        | None -> new EmptyStatement(getPos parseState, true) :> IExprInteractiveStatement }


//------------------------------------------------------------------------------
// Variable definition
//------------------------------------------------------------------------------

MaybeVarDef:
    | LET ID EQUALS Expression SEMI
      { let kw = new Keyword(getPosI parseState 1) in
        let id = new Identificator($2, getPosI parseState 2) in
        Some (new VariableDefinition(kw, id, $4, getPos parseState)) }
    | LET ID EQUALS Expression
      { logErrorPos (getEndPos parseState) "Did you forget `;`?";
        let kw = new Keyword(getPosI parseState 1) in
        let id = new Identificator($2, getPosI parseState 2) in
        Some (new VariableDefinition(kw, id, $4, getPos parseState)) }
    | LET EQUALS Expression SEMI
      { logErrorPos (getBetweenPos parseState 1 3) "Variable name excpected.";
        None }
    | LET error EQUALS Expression SEMI
      { logErrorPos (getBetweenPos parseState 1 3) "Variable name excpected.";
        None }
    | LET error SEMI
      { logErrorPos (getBetweenPos parseState 1 3) "Variable definition excpected.";
        None }

VarDefsList:
    |
      { new ResizeArray<VariableDefinition>() }
    | VarDefsListNonEmpty
      { $1 }

VarDefsListNonEmpty:
    | MaybeVarDef
      { let mutable x = new ResizeArray<VariableDefinition>() in
        match $1 with
        | Some(varDef) -> x.Add(varDef); x
        | None -> x }
    | VarDefsListNonEmpty MaybeVarDef
      { match $2 with
        | Some(varDef) -> $1.Add(varDef); $1
        | None -> $1 }


//------------------------------------------------------------------------------
// Function definition
//------------------------------------------------------------------------------

MaybeFunDef:
    | FUN ID FunDefParams RichExpressionBraces
      { let kw = new Keyword(getPosI parseState 1) in
        let id = new Identificator($2, getPosI parseState 2) in
        Some (new FunctionDefinition(kw, id, $3, $4, getPos parseState)) }
    | FUN error RichExpressionBraces
      { logErrorPos (getBetweenPos parseState 1 3) "Function identifier with parameters excpected.";
        None }


MaybeFunDefParams:
    |
      { new ImmutableListPos<OptionalParameter>(getStartPos parseState) }
    | FunDefParams
      { $1 }

FunDefParams:
    | LPAREN OptParamsList RPAREN
      { new ImmutableListPos<OptionalParameter>($2, getPos parseState) }
    | LPAREN error RPAREN
      { logErrorPos (getBetweenPos parseState 1 3) "Excpected parameters with optional default value separated by comma.";
        new ImmutableListPos<OptionalParameter>(getPos parseState) }

RichExpressionBraces:
    | LBRACE VarDefsList Expression RBRACE
      { new RichExpression($2, $3, getPosI parseState 1, getPosI parseState 4, getPos parseState) }
    | LBRACE error RBRACE
      { logErrorPos (getBetweenPos parseState 1 3) "Excpected expression with optional local variable definitions before it divided by semicolon.";
        new RichExpression(getPosI parseState 1, getPosI parseState 3, getPos parseState) }


OptParamsList:
    |
      { new ResizeArray<OptionalParameter>() }
    | OptParamsListNonEmpty
      { $1 }

OptParamsListNonEmpty:
    | OptParam
      { let mutable x = new ResizeArray<OptionalParameter>() in x.Add($1); x }
    | OptParamsListNonEmpty COMMA OptParam
      { $1.Add($3); $1 }

OptParam:
    | ID
      { let id = new Identificator($1, getPosI parseState 1) in
        new OptionalParameter(id, getPos parseState) }
    | ID EQUALS Expression
      { let id = new Identificator($1, getPosI parseState 1) in
        new OptionalParameter(id, $3, getPos parseState) }


//------------------------------------------------------------------------------
// L-system definition
//------------------------------------------------------------------------------

Lsystem:
    | LSYSTEM ID MaybeFunDefParams LsystemBody
      { let kw = new Keyword(getPosI parseState 1) in
        let id = new Identificator($2, getPosI parseState 2) in
        new Lsystem(kw, id, $3, $4, getPos parseState) }

LsystemBody:
    | LBRACE LsysStatementsList RBRACE
      { new ImmutableListPos<ILsystemStatement>($2, getPosI parseState 1, getPosI parseState 3, getPos parseState)  }
    | LBRACE error RBRACE
      { logErrorPos (getBetweenPos parseState 1 3) "Lsystem statements excpected.";
        new ImmutableListPos<ILsystemStatement>(getPosI parseState 1, getPosI parseState 3, getPos parseState)  }

LsysStatementsList:
    |
      { new ResizeArray<ILsystemStatement>() }
    | LsysStatementsList LsysStatement
      { $1.Add($2); $1 }

LsysStatement:
    | MaybeRewriteRule
      { match $1 with
        | Some(rr) -> rr :> ILsystemStatement
        | None -> new EmptyStatement(getPos parseState, true) :> ILsystemStatement }
    | MaybeVarDef
      { match $1 with
        | Some(varDef) -> varDef :> ILsystemStatement
        | None -> new EmptyStatement(getPos parseState, true) :> ILsystemStatement }
    | MaybeSymbolsDef
      { match $1 with
        | Some(symDef) -> symDef :> ILsystemStatement
        | None -> new EmptyStatement(getPos parseState, true) :> ILsystemStatement }
    | MaybeFunDef
      { match $1 with
        | Some(funDef) -> funDef :> ILsystemStatement
        | None -> new EmptyStatement(getPos parseState, true) :> ILsystemStatement }
    | SEMI
      { new EmptyStatement(getPos parseState) :> ILsystemStatement }
    | error
      { logErrorLastPos "Excpected L-System statement.";
        new EmptyStatement(ThreadStatic.LasErrorPos, true) :> ILsystemStatement }

MaybeSymbolsDef:
    | SET ID EQUALS SymbolWithArgsList SEMI
      { let kw = new Keyword(getPosI parseState 1) in
        let id = new Identificator($2, getPosI parseState 2) in
        Some (new SymbolsDefinition(kw, id, $4, getPos parseState)) }
    | SET ID EQUALS SymbolWithArgsList
      { logErrorPos (getEndPos parseState) "Did you forget `;`?";
        let kw = new Keyword(getPosI parseState 1) in
        let id = new Identificator($2, getPosI parseState 2) in
        Some (new SymbolsDefinition(kw, id, $4, getPos parseState)) }
    | SET EQUALS SymbolWithArgsList SEMI
      { logErrorPos (getBetweenPos parseState 1 3) "Symbols name excpected.";
        None }
    | SET error EQUALS SymbolWithArgsList SEMI
      { logErrorPos (getBetweenPos parseState 1 3) "Symbols name excpected.";
        None }
    | SET error SEMI
      { logErrorPos (getBetweenPos parseState 1 3) "Symbols definition excpected.";
        None }


//------------------------------------------------------------------------------
// L-system's rewrite rule
//------------------------------------------------------------------------------

MaybeRewriteRule:
    | REWRITE RrPattern OptRrVarDefs OptRrCondition TO RrReplac OptRrWeight SEMI
      { let rwKw = new Keyword(getPosI parseState 1) in
        let (lCtxt, patt, rCtxt) = $2 in
        let (vdKw, vds) = $3 in
        let (cKw, cond) = $4 in
        let toKw = new Keyword(getPosI parseState 5) in
        let (rKw, replac) = $6 in
        let (wKw, weight) = $7 in
        let semi = new Keyword(getPosI parseState 8) in
        let keywords = new ImmutableList<Keyword>(rwKw, vdKw, cKw, toKw, rKw, wKw) in
        Some (new RewriteRule(patt, lCtxt, rCtxt, vds, cond, replac, weight, keywords, getPos parseState)) }
    | REWRITE RrPattern OptRrVarDefs OptRrCondition TO RrReplac OptRrWeight
      { logErrorPos (getEndPos parseState) "Did you forget `;`?";
        let rwKw = new Keyword(getPosI parseState 1) in
        let (lCtxt, patt, rCtxt) = $2 in
        let (vdKw, vds) = $3 in
        let (cKw, cond) = $4 in
        let toKw = new Keyword(getPosI parseState 5) in
        let (rKw, replac) = $6 in
        let (wKw, weight) = $7 in
        let semi = new Keyword(getPosI parseState 8) in
        let keywords = new ImmutableList<Keyword>(rwKw, vdKw, cKw, toKw, rKw, wKw) in
        Some (new RewriteRule(patt, lCtxt, rCtxt, vds, cond, replac, weight, keywords, getPos parseState)) }
    | REWRITE error SEMI
      { logErrorPos (getBetweenPos parseState 1 3) "Excpected rewrite rule.";
        None }

RrPattern:
    | OptRrCtxt SymbolPattern OptRrCtxt
      { ($1, $2, $3) }

OptRrVarDefs:
    |
      { let vds = new ImmutableListPos<VariableDefinition>(getStartPos parseState) in
        (Keyword.Empty, vds) }
    | WITH RrVarDefsList
      { let kw = new Keyword(getPosI parseState 1) in
        let vds = new ImmutableListPos<VariableDefinition>($2, getPosI parseState 1, getPosI parseState 3, getPos parseState) in
        (kw, vds) }
    | WITH
      { logNoticePos (getPosI parseState 1) "Empty variable definition block found.";
        let kw = new Keyword(getPosI parseState 1) in
        let vds = ImmutableListPos<VariableDefinition>(getStartPos parseState) in
        (kw, vds) }

OptRrCondition:
    |
      { let expr = new Expression(getStartPos parseState) in
        (Keyword.Empty, expr) }
    | WHERE Expression
      { let kw = new Keyword(getPosI parseState 1) in
        (kw, $2) }
    | WHERE
      { logNoticePos (getPosI parseState 1) "Empty condition found.";
        let kw = new Keyword(getPosI parseState 1) in
        (kw, new Expression(getStartPos parseState)) }

RrReplac:
    | NOTHING
      { let kw = new Keyword(getPosI parseState 1) in
        let list = new ImmutableListPos<SymbolExprArgs>(getPos parseState) in
        (kw, list)}
    | SymbolWithArgsList
      { if $1.Length = 0 then logNoticePos (getStartPos parseState) "Empty replacement block found, you can use keyword `nothing` to improve source code readability." else ();
        (Keyword.Empty, $1) }

OptRrWeight:
    |
      { let expr = new Expression(getStartPos parseState) in
        (Keyword.Empty, expr) }
    | WEIGHT Expression
      { let kw = new Keyword(getPosI parseState 1) in
        (kw, $2) }


OptRrCtxt:
    |
      { new ImmutableListPos<SymbolPattern>(getStartPos parseState) }
    | LBRACE SymbolPatternsList RBRACE
      { new ImmutableListPos<SymbolPattern>($2, getPosI parseState 1, getPosI parseState 3, getPos parseState) }
    | LBRACE error RBRACE
      { logErrorPos (getBetweenPos parseState 1 3) "Excpected symbol patterns as context.";
        new ImmutableListPos<SymbolPattern>(getPosI parseState 1, getPosI parseState 3, getPos parseState) }

RrVarDef:
    | ID EQUALS Expression
      { let id = new Identificator($1, getPosI parseState 1) in
        new VariableDefinition(Keyword.Empty, id, $3, getPos parseState) }

RrVarDefsList:
    |
      { new ResizeArray<VariableDefinition>() }
    | RrVarDefsListNonEmpty
      { $1 }

RrVarDefsListNonEmpty:
    | RrVarDef
      { let mutable x = new ResizeArray<VariableDefinition>() in x.Add($1); x }
    | RrVarDefsListNonEmpty COMMA RrVarDef
      { $1.Add($3); $1 }

//------------------------------------------------------------------------------
// L-system's symbols (modules)
//------------------------------------------------------------------------------

SymbolPattern:
    | Symbol
      { new SymbolPattern($1, getPos parseState) }
    | Symbol LPAREN IdsCommaList RPAREN
      { new SymbolPattern($1, $3, getPos parseState) }

SymbolPatternsList:
    |
      { new ResizeArray<SymbolPattern>() }
    | SymbolPatternsList SymbolPattern
      { $1.Add($2); $1 }

SymbolWithArgs:
    | Symbol
      { new SymbolExprArgs($1, getPos parseState) }
    | Symbol LPAREN ExpressionsList RPAREN
      { new SymbolExprArgs($1, $3, getPos parseState) }

SymbolWithArgsList:
    |
      { new ImmutableListPos<SymbolExprArgs>(getStartPos parseState) }
    | SymbolWithArgsListNonEmpty
      { new ImmutableListPos<SymbolExprArgs>($1, getPos parseState) }

SymbolWithArgsListNonEmpty:
    | SymbolWithArgs
      { let mutable x = new ResizeArray<SymbolExprArgs>() in x.Add($1); x }
    | SymbolWithArgsListNonEmpty SymbolWithArgs
      { $1.Add($2); $1 }

Symbol:
    | ID
      { new Symbol($1, getPos parseState) }
    | OPERATOR
      { new Symbol($1, getPos parseState) }


//------------------------------------------------------------------------------
// Expressions
//------------------------------------------------------------------------------

Expression:
    |
      { logError parseState "Excpected non-empty expression.";
        new Expression(getStartPos parseState) }
    | ExpressionNonEmpty
      { new Expression($1, getPos parseState) }

ExpressionNonEmpty:
    | ExprMember
      { let mutable x = new ResizeArray<IExpressionMember>() in x.Add($1); x }
    | ExpressionNonEmpty ExprMember
      { $1.Add($2); $1 }

ExprMember:
    | FLOAT
      { new FloatConstant($1, getPos parseState) :> IExpressionMember }
    | ID
      { new Identificator($1, getPos parseState) :> IExpressionMember }
    | ExpressionsArray
      { $1 :> IExpressionMember }
    | OPERATOR
      { new Operator($1, getPos parseState) :> IExpressionMember }
    | ExprIndexer
      { $1 :> IExpressionMember }
    | ExprFunc
      { $1 :> IExpressionMember }
    | ExprParen
      { $1 :> IExpressionMember }


ExpressionsArray:
    | LBRACE ExpressionsList RBRACE
      { new ExpressionsArray($2, getPos parseState) }
    | LBRACE error RBRACE
      { logError parseState "Expeted list of expression (divided by comma).";
        new ExpressionsArray(getPos parseState) }

ExpressionsList:
    |
      { new ResizeArray<Expression>() }
    | ExpressionsListNonEmpty
      { $1 }

ExpressionsListNonEmpty:
    | ExpressionNonEmpty
      { let mutable x = new ResizeArray<Expression>() in
        let expr = new Expression($1, getPos parseState) in
        x.Add(expr);
        x }
    | ExpressionsListNonEmpty COMMA Expression
      { $1.Add($3); $1 }

ExprIndexer:
    | LBRACK Expression RBRACK
      { new ExpressionIndexer($2, getPos parseState) }

ExprFunc:
    | ID LPAREN ExpressionsList RPAREN
      { let id = new Identificator($1, getPosI parseState 1) in
        new ExpressionFunction(id, $3, getPos parseState) }

ExprParen:
    | LPAREN Expression RPAREN
      { new ExpressionBracketed($2, getPos parseState) }


//------------------------------------------------------------------------------
// Other
//------------------------------------------------------------------------------

IdsCommaList:
    |
      { new ResizeArray<Identificator>() }
    | IdsCommaListNonEmpty
      { $1 }

IdsCommaListNonEmpty:
    | ID
      { let id = new Identificator($1, getPos parseState) in
        let mutable x = new ResizeArray<Identificator>() in
        x.Add(id);
        x }
    | IdsCommaListNonEmpty COMMA ID
      { let id = new Identificator($3, getPosI parseState 3) in
        $1.Add(id);
        $1 }
