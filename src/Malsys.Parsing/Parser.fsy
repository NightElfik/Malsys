%{

open System
open Microsoft.FSharp.Text.Parsing

open MessagesLogger
open Malsys
open Malsys.Ast
open Malsys.Compilers

let logError parserState msg =
    MessagesLogger.logMessage CompilerMessageType.Error parserState msg


// This function is called by the generated parser code. Returning initiates error recovery.
let parse_error_rich = Some (fun (ctxt: ParseErrorContext<_>) ->
    logError ctxt.ParseState "Parser error.")

let toAstPos (parserState : IParseState) =
    new Position(parserState.ResultRange)

%}

%token <string> ID
%token LET LSYSTEM
%token EQUALS SEMI COMMA QMARK COLON RARROW
%token LPAREN RPAREN LBRACE RBRACE LBRACK RBRACK
%token <float> FLOAT
%token <string> OPERATOR
%token DOC_BEGIN DOC_END
%token EOF


%start parseLsystemStatements
%type <IInputStatement[]> parseLsystemStatements

%start parseExpression
%type <Expression> parseExpression

%start parseExprInteractiveStatements
%type <IExprInteractiveStatement[]> parseExprInteractiveStatements

%%


parseLsystemStatements:
    | LsystemStatementsList EOF
      { ($1 :> ResizeArray<IInputStatement>).ToArray() }

parseExpression:
    | Expression EOF
      { $1 }

parseExprInteractiveStatements:
    | ExprInteractiveStatementList EOF
      { ($1 :> ResizeArray<IExprInteractiveStatement>).ToArray() }


LsystemStatementsList:
    |
      { new ResizeArray<IInputStatement>() }
    | LsystemStatementsList LsystemStatement
      { $1.Add($2); $1 }

LsystemStatement:
    | VarDef SEMI
      { $1 :> IInputStatement }
    | FuncDef
      { $1 :> IInputStatement }
    | Lsystem
      { $1 :> IInputStatement }


ExprInteractiveStatementList:
    |
      { new ResizeArray<IExprInteractiveStatement>() }
    | ExprInteractiveStatementList ExprInteractiveStatement
      { $1.Add($2); $1 }
    | ExprInteractiveStatementList SEMI
      { $1 }

ExprInteractiveStatement:
    | Expression SEMI
      { $1 :> IExprInteractiveStatement }
    | VarDef SEMI
      { $1 :> IExprInteractiveStatement }
    | FuncDef
      { $1 :> IExprInteractiveStatement }


// Empty list OR variable definitions list divided by semicolon (but no semicolon on the end)
VarDefsList:
    |
      { new ResizeArray<VariableDefinition>() }
    | VarDefsListNonEmpty
      { $1 }

// Empty list OR variable definitions list divided by semicolon with extra semicolon on the end
VarDefsListSemi:
    |
      { new ResizeArray<VariableDefinition>() }
    | VarDefsListNonEmpty SEMI
      { $1 }

VarDefsListNonEmpty:
    | VarDef
      { let mutable x = new ResizeArray<VariableDefinition>() in x.Add($1); x }
    | VarDefsListNonEmpty SEMI VarDef
      { $1.Add($3); $1 }

VarDef:
    | LetKw Id EQUALS Expression
      { new VariableDefinition($1, $2, $4, toAstPos parseState) }


FuncDef:
    | LetKw Id FuncDefParams LBRACE RichExpression RBRACE
      { new FunctionDefinition($1, $2, $3, $5, toAstPos parseState) }

FuncDefParams:
    | LPAREN OptParamsList RPAREN
      { $2 }
    | LPAREN error RPAREN
      { logError parseState "Failed to parse parameters.";
        new ResizeArray<OptionalParameter>() }

RichExpression:
    | VarDefsListSemi Expression
      { new RichExpression($1, $2, toAstPos parseState) }
    | error
      { logError parseState "Failed to parse 'rich expression', expression with optional local variables definition before it.";
        new RichExpression(Position.Unknown) }


OptParamsList:
    |
      { new ResizeArray<OptionalParameter>() }
    | OptParamsListNonEmpty
      { $1 }

OptParamsListNonEmpty:
    | OptParam
      { let mutable x = new ResizeArray<OptionalParameter>() in x.Add($1); x }
    | OptParamsListNonEmpty COMMA OptParam
      { $1.Add($3); $1 }

OptParam:
    | Id
      { new OptionalParameter($1, toAstPos parseState) }
    | Id EQUALS Expression
      { new OptionalParameter($1, $3, toAstPos parseState) }


Lsystem:
    | LsysKw Id LBRACE LsysStatementsList RBRACE
      { new Lsystem($1, $2, $4, toAstPos parseState) }
    | LsysKw Id FuncDefParams LBRACE LsysStatementsList RBRACE
      { new Lsystem($1, $2, $3, $5, toAstPos parseState) }

LsysStatementsList:
    |
      { new ResizeArray<ILsystemStatement>() }
    | LsysStatementsList LsysStatement
      { $1.Add($2); $1 }

LsysStatement:
    | VarDef SEMI
      { $1 :> ILsystemStatement }
    | RewriteRule SEMI
      { $1 :> ILsystemStatement }


RewriteRule:
    | MaybeLCtxt SymbolPattern MaybeRCtxt MaybeCondition MaybeProbab RARROW MaybeVarDefs SymbolsWithParamsList
      { new RewriteRule($2, $1, $3, $4, $5, $7, $8, toAstPos parseState) }

MaybeLCtxt:
    |
      { new ImmutableListPos<SymbolPattern>(toAstPos parseState) }
    | LBRACE SymbolsPatternsList RBRACE
      { new ImmutableListPos<SymbolPattern>($2, toAstPos parseState) }

MaybeRCtxt:
    |
      { new ImmutableListPos<SymbolPattern>(toAstPos parseState) }
    | LBRACE SymbolsPatternsList RBRACE
      { new ImmutableListPos<SymbolPattern>($2, toAstPos parseState) }

MaybeCondition:
    |
      { new RichExpression(toAstPos parseState) }
    | QMARK LBRACE VarDefsListSemi Expression RBRACE
      { new RichExpression($3, $4, toAstPos parseState) }

MaybeProbab:
    |
      { new RichExpression(toAstPos parseState) }
    | COLON LBRACE VarDefsListSemi Expression RBRACE
      { new RichExpression($3, $4, toAstPos parseState) }

MaybeVarDefs:
    |
      { new ImmutableListPos<VariableDefinition>(toAstPos parseState) }
    | LBRACE VarDefsList RBRACE
      { new ImmutableListPos<VariableDefinition>($2, toAstPos parseState) }


SymbolsPatternsList:
    |
      { new ResizeArray<SymbolPattern>() }
    | SymbolsPatternsList SymbolPattern
      { $1.Add($2); $1 }

SymbolPattern:
    | Symbol
      { new SymbolPattern($1, toAstPos parseState) }
    | Symbol LPAREN IdsCommaList RPAREN
      { new SymbolPattern($1, $3, toAstPos parseState) }

SymbolsWithParamsList:
    |
      { new ResizeArray<SymbolExprArgs>() }
    | SymbolsWithParamsList SymbolWithArgs
      { $1.Add($2); $1 }

SymbolWithArgs:
    | Symbol
      { new SymbolExprArgs($1, toAstPos parseState) }
    | Symbol LPAREN ExpressionsList RPAREN
      { new SymbolExprArgs($1, $3, toAstPos parseState) }

Symbol:
    | ID
      { new Symbol($1, toAstPos parseState) }
    | OPERATOR
      { new Symbol($1, toAstPos parseState) }


ExpressionsArray:
    | LBRACE ExpressionsList RBRACE
      { new ExpressionsArray($2, toAstPos parseState) }

ExpressionsList:
    |
      { new ResizeArray<Expression>() }
    | ExpressionsListNonEmpty
      { $1 }

ExpressionsListNonEmpty:
    | Expression
      { let mutable x = new ResizeArray<Expression>() in x.Add($1); x }
    | ExpressionsListNonEmpty COMMA Expression
      { $1.Add($3); $1 }


Expression:
    |
      { logError parseState "Excpected expression.";
        new Expression(toAstPos parseState) }
    | ExpressionNonEmpty
      { new Expression($1, toAstPos parseState) }

ExpressionNonEmpty:
    | ExprMember
      { let mutable x = new ResizeArray<IExpressionMember>() in x.Add($1); x }
    | ExpressionNonEmpty ExprMember
      { $1.Add($2); $1 }

ExprMember:
    | Float
      { $1 :> IExpressionMember }
    | Id
      { $1 :> IExpressionMember }
    | ExpressionsArray
      { $1 :> IExpressionMember }
    | Operator
      { $1 :> IExpressionMember }
    | ExprIndexer
      { $1 :> IExpressionMember }
    | ExprFunc
      { $1 :> IExpressionMember }
    | ExprParen
      { $1 :> IExpressionMember }


ExprIndexer:
    | LBRACK Expression RBRACK
      { new ExpressionIndexer($2, toAstPos parseState) }

ExprFunc:
    | Id LPAREN ExpressionsList RPAREN
      { new ExpressionFunction($1, $3, toAstPos parseState) }

ExprParen:
    | LPAREN Expression RPAREN
      { new ExpressionBracketed($2, toAstPos parseState) }


IdsCommaList:
    |
      { new ResizeArray<Identificator>() }
    | IdsCommaListNonEmpty
      { $1 }

IdsCommaListNonEmpty:
    | Id
      { let mutable x = new ResizeArray<Identificator>() in x.Add($1); x }
    | IdsCommaListNonEmpty COMMA Id
      { $1.Add($3); $1 }

Id:
    | ID
      { new Identificator($1, toAstPos parseState) }

LsysKw:
    | LSYSTEM
      { new Keyword(toAstPos parseState) }

LetKw:
    | LET
      { new Keyword(toAstPos parseState) }

Operator:
    | OPERATOR
      { new Operator($1, toAstPos parseState) }

Float:
    | FLOAT
      { new FloatConstant($1, toAstPos parseState) }
