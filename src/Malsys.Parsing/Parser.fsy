%{

open System
open Microsoft.FSharp.Text.Parsing

open Malsys
open Malsys.Ast

let parse_error_rich = Some (fun (ctxt: ParseErrorContext<_>) ->
    raise <| ParserException(ctxt))

let toAstPos range =
    new Position(range)

%}

%token <string> ID UNRECOGNIZED
%token LET LSYSTEM
%token EQUALS SEMI COMMA QMARK COLON RARROW
%token LPAREN RPAREN LBRACE RBRACE LBRACK RBRACK
%token <float> FLOAT
%token <string> OPERATOR
%token EOF


%start start
%type <InputFile> start

%start parseExpression
%type <Expression> parseExpression

%%


start:
    | StatementsList
      { new InputFile($1) }

parseExpression:
    | Expression
      { $1 }

StatementsList:
    |
      { new ResizeArray<IInputFileStatement>() }
    | StatementsList Statement
      { $1.Add($2); $1 }

Statement:
    | VarDef SEMI
      { $1 :> IInputFileStatement }
    | Lsystem
      { $1 :> IInputFileStatement }


// Empty OR variable definitions list divided by semicolon
VarDefsList:
    |
      { new ResizeArray<VariableDefinition>() }
    | VarDefsListNonEmpty
      { $1 }

// Empty OR variable definitions list divided by semicolon with extra semicolon on the end
VarDefsListSemi:
    |
      { new ResizeArray<VariableDefinition>() }
    | VarDefsListNonEmpty SEMI
      { $1 }

VarDefsListNonEmpty:
    | VarDef
      { let mutable x = new ResizeArray<VariableDefinition>() in x.Add($1); x }
    | VarDefsListNonEmpty SEMI VarDef
      { $1.Add($3); $1 }

VarDef:
    | LetKw Id EQUALS VarValue
      { new VariableDefinition($1, $2, $4, toAstPos parseState.ResultRange) }

VarValue:
    | Expression
      { $1 :> IVariableValue }
    | LBRACE VarValueList RBRACE
      { $2 :> IVariableValue }

VarValueList:
    |
      { new VariableValuesArray() }
    | VarValueListNonEmpty
      { new VariableValuesArray($1) }

VarValueListNonEmpty:
    | VarValue
      { let mutable x = new ResizeArray<IVariableValue>() in x.Add($1); x }
    | VarValueListNonEmpty COMMA VarValue
      { $1.Add($3); $1 }


Lsystem:
    | LsysKw Id LBRACE LsysStatementsList RBRACE
      { new Lsystem($1, $2, $4, toAstPos parseState.ResultRange) }

LsysStatementsList:
    |
      { new ResizeArray<ILsystemStatement>() }
    | LsysStatementsList LsysStatement
      { $1.Add($2); $1 }

LsysStatement:
    | VarDef SEMI
      { $1 :> ILsystemStatement }
    | RewriteRule SEMI
      { $1 :> ILsystemStatement }


RewriteRule:
    | MaybeLCtxt SymbolPattern MaybeRCtxt MaybeCondition MaybeProbab RARROW MaybeVarDefs SymbolsWithParamsList
      { new RewriteRule($1, $2, $3, $4, $5, $7, $8, toAstPos parseState.ResultRange) }

MaybeLCtxt:
    |
      { null }
    | LBRACE SymbolsPatternsList RBRACE
      { new RrContext($2, toAstPos parseState.ResultRange) }

MaybeRCtxt:
    |
      { null }
    | LBRACE SymbolsPatternsList RBRACE
      { new RrContext($2, toAstPos parseState.ResultRange) }

MaybeCondition:
    |
      { null }
    | QMARK LBRACE VarDefsListSemi Expression RBRACE
      { new RrCondition($3, $4, toAstPos parseState.ResultRange) }

MaybeProbab:
    |
      { null }
    | COLON LBRACE VarDefsListSemi Expression RBRACE
      { new RrProbability($3, $4, toAstPos parseState.ResultRange) }

MaybeVarDefs:
    |
      { null }
    | LBRACE VarDefsList RBRACE
      { $2 }


SymbolsPatternsList:
    |
      { new ResizeArray<SymbolPattern>() }
    | SymbolsPatternsList SymbolPattern
      { $1.Add($2); $1 }

SymbolPattern:
    | Symbol
      { new SymbolPattern($1, toAstPos parseState.ResultRange) }
    | Symbol LPAREN IdsCommaList RPAREN
      { new SymbolPattern($1, $3, toAstPos parseState.ResultRange) }

SymbolsWithParamsList:
    |
      { new ResizeArray<SymbolWithParams>() }
    | SymbolsWithParamsList SymbolWithParams
      { $1.Add($2); $1 }

SymbolWithParams:
    | Symbol
      { new SymbolWithParams($1, toAstPos parseState.ResultRange) }
    | Symbol LPAREN ExpressionCommaList RPAREN
      { new SymbolWithParams($1, $3, toAstPos parseState.ResultRange) }

Symbol:
    | ID
      { new Symbol($1, toAstPos parseState.ResultRange) }
    | UNRECOGNIZED
      { new Symbol($1, toAstPos parseState.ResultRange) }
    | OPERATOR
      { new Symbol($1, toAstPos parseState.ResultRange) }


ExpressionCommaList:
    |
      { new ResizeArray<Expression>() }
    | ExpressionCommaListNonEmpty
      { $1 }

ExpressionCommaListNonEmpty:
    | Expression
      { let mutable x = new ResizeArray<Expression>() in x.Add($1); x }
    | ExpressionCommaListNonEmpty COMMA Expression
      { $1.Add($3); $1 }


Expression:
    | ExprBuilder
      { new Expression($1, toAstPos parseState.ResultRange) }

ExprBuilder:
    |
      { new ResizeArray<IExpressionMember>() }
    | ExprBuilder Float
      { $1.Add($2); $1 }
    | ExprBuilder Id
      { $1.Add($2); $1 }
    | ExprBuilder Operator
      { $1.Add($2); $1 }
    | ExprBuilder ExprIndexer
      { $1.Add($2); $1 }
    | ExprBuilder ExprFunc
      { $1.Add($2); $1 }
    | ExprBuilder ExprParen
      { $1.Add($2); $1 }

ExprIndexer:
    | LBRACK Expression RBRACK
      { new ExpressionIndexer($2, toAstPos parseState.ResultRange) }

ExprFunc:
    | Id LPAREN ExpressionCommaList RPAREN
      { new ExpressionFunction($1, $3, toAstPos parseState.ResultRange) }

ExprParen:
    | LPAREN Expression RPAREN
      { new ExpressionBracketed($2, toAstPos parseState.ResultRange) }


IdsCommaList:
    |
      { new ResizeArray<Identificator>() }
    | IdsCommaListNonEmpty
      { $1 }

IdsCommaListNonEmpty:
    | Id
      { let mutable x = new ResizeArray<Identificator>() in x.Add($1); x }
    | IdsCommaListNonEmpty COMMA Id
      { $1.Add($3); $1 }

Id:
    | ReId
      { $1 }
    | UnId
      { $1 }

ReId:
    | ID
      { new Identificator($1, toAstPos parseState.ResultRange) }

UnId:
    | UNRECOGNIZED
      { new Identificator($1, toAstPos parseState.ResultRange) }

LsysKw:
    | LSYSTEM
      { new Keyword(toAstPos parseState.ResultRange) }

LetKw:
    | LET
      { new Keyword(toAstPos parseState.ResultRange) }

Operator:
    | OPERATOR
      { new Operator($1, toAstPos parseState.ResultRange) }

Float:
    | FLOAT
      { new FloatConstant($1, toAstPos parseState.ResultRange) }
