
//------------------------------------------------------------------------------
// Header of parser file.
//------------------------------------------------------------------------------

%{

open System
open Microsoft.FSharp.Text.Parsing

open MessagesLogger
open Malsys
open Malsys.Ast
open Malsys.Compilers



// This function is called by the generated parser code. Returning initiates error recovery.
// Saves last error position to thread-static messages logger.
let parse_error_rich = Some (fun (ctxt: ParseErrorContext<_>) ->
   MessagesLogger.setErrPos (new Position(ctxt.ParseState.ResultRange))  )


let getLastErrorPos = MessagesLogger.getLastErrPos


let logError parserState msg =
    MessagesLogger.logMessage CompilerMessageType.Error parserState msg

let logNoticePos pos msg =
    MessagesLogger.logMessagePos CompilerMessageType.Notice pos msg

let logErrorPos pos msg =
    MessagesLogger.logMessagePos CompilerMessageType.Error pos msg


let getPos (parserState : IParseState) =
    new Position(parserState.ResultRange)

let getPosI (parserState : IParseState) index =
    new Position(parserState.InputRange(index))

let getPosRange (parserState : IParseState) fromI toI =
    new Position((fst (parserState.InputRange(fromI)), snd (parserState.InputRange(toI))))

let getPosFromTo (fromPos : Position) (toPos : Position) =
    new Position(fromPos.BeginLine, fromPos.BeginColumn, toPos.EndLine, toPos.EndColumn)

let getPosBetween (parserState : IParseState) fromI toI =
    new Position((snd (parserState.InputRange(fromI)), fst (parserState.InputRange(toI))))

let getStartPos (parserState : IParseState) =
    let startPos = fst parserState.ResultRange
    new Position(startPos, startPos)

let getEndPos (parserState : IParseState) =
    let endPos = snd parserState.ResultRange
    new Position(endPos, endPos)


let optionToStatement parseState (option : Option<#ILsystemStatement>) =
    match option with
        | Some(value) -> value
        | None -> new EmptyStatement(getPos parseState, true) :> ILsystemStatement

%}


//------------------------------------------------------------------------------
// Tokens lists.
//------------------------------------------------------------------------------

%token <string> ID
%token <Keyword> LSYSTEM REWRITE WITH WHERE TO OR WEIGHT NOTHING CONSIDER LET SET FUN RETURN INTERPRET AS
%token EQUALS SEMI COMMA QMARK COLON
%token LPAREN RPAREN LBRACE RBRACE
%token <float * ConstantFormat> FLOAT
%token <string> OPERATOR LBRACK RBRACK
%token EOF


//------------------------------------------------------------------------------
// Priorities of tokens.
//------------------------------------------------------------------------------

// ID . LPAREN -> ExprFunc (not ExprMember ExprParen)
%nonassoc ID
%nonassoc LPAREN


//------------------------------------------------------------------------------
// Start (enter) rules and types.
//------------------------------------------------------------------------------

%start ParseInput
%type <InputBlock> ParseInput

// helper start rule, especially for unit testing

%start ParseBinding
%type <Binding> ParseBinding

%%


//------------------------------------------------------------------------------
// Start rules.
//------------------------------------------------------------------------------

ParseInput:
    | InputStatementsList EOF
      { new InputBlock($1 :> ResizeArray<IInputStatement>) }


ParseBinding:
    | MaybeBinding EOF
      { match $1 with
        | Some(bind) -> bind
        | None -> null }
    | error EOF
      { logErrorPos getLastErrorPos "Syntax error.";
        null }


//------------------------------------------------------------------------------
// Input.
//------------------------------------------------------------------------------

InputStatementsList:
    |
      { new ResizeArray<IInputStatement>() }
    | InputStatementsList InputStatement
      { $1.Add($2); $1 }

InputStatement:
    | MaybeBinding
      { match $1 with
        | Some(bind) -> bind :> IInputStatement
        | None -> new EmptyStatement(getPos parseState, true) :> IInputStatement }
    | SEMI
      { new EmptyStatement(getPos parseState) :> IInputStatement }
    | error
      { logErrorPos getLastErrorPos "Excpected input statement (L-Sysytem, variable or function definition).";
        new EmptyStatement(ThreadStatic.LasErrorPos, true) :> IInputStatement }


//------------------------------------------------------------------------------
// Bindings.
//------------------------------------------------------------------------------

MaybeBinding:
    | MaybeExprBind
      { $1 }
    | MaybeFunBind
      { $1 }
    | MaybeSymbolListBind
      { $1 }
    | MaybeLsystemBind
      { $1 }

BindingsList:
    |
      { ImmutableListPos<Binding>.Empty }
    | BindingsListNonEmpty
      { new ImmutableListPos<Binding>($1 :> ResizeArray<Binding>, getPos parseState) }

BindingsListNonEmpty:
    | MaybeBinding
      { let mutable x = new ResizeArray<Binding>() in
        match $1 with
        | Some(bind) -> x.Add(bind); x
        | None -> x }
    | BindingsListNonEmpty MaybeBinding
      { match $2 with
        | Some(bind) -> $1.Add(bind); $1
        | None -> $1 }


//------------------------------------------------------------------------------
// Expression binding.
//------------------------------------------------------------------------------

MaybeExprBind:
    | LET id EQUALS Expression SEMI
      { Some (new Binding($2, $4, getPos parseState)) }
    | LET error SEMI
      { logErrorPos (getPosBetween parseState 1 3) "Expression binding excpected.";
        None }


//------------------------------------------------------------------------------
// Function binding.
//------------------------------------------------------------------------------

MaybeFunBind:
    | FUN id ExprParams FunBody
      { let (binds, expr) = $4 in
        let func = new Function($3, binds, expr, getPosRange parseState 3 4) in
        Some (new Binding($2, func, getPos parseState)) }
    | FUN id error FunBody
      { logErrorPos (getPosBetween parseState 2 4) "Function parameters excpected.";
        None }

ExprParams:
    | LPAREN OptParamsList RPAREN
      { ($2 :> ImmutableListPos<OptionalParameter>).AddSeparators(getPosI parseState 1, getPosI parseState 3, getPos parseState) }
    | LPAREN error RPAREN
      { logErrorPos (getPosBetween parseState 1 3) "Excpected parameters with optional default value separated by comma.";
        new ImmutableListPos<OptionalParameter>(getPosI parseState 1, getPosI parseState 3, getPos parseState) }

FunBody:
    | LBRACE BindingsList RETURN Expression SEMI RBRACE
      { let binds = $2.AddSeparators(getPosI parseState 1, getPosI parseState 6) in
        (binds, $4) }
    | LBRACE error RBRACE
      { logErrorPos (getPosBetween parseState 1 3) "Excpected function body.";
        let vars = new ImmutableListPos<Binding>(getPosI parseState 1, getPosI parseState 3, getPos parseState) in
        (vars, Expression.Empty) }

OptParamsList:
    |
      { ImmutableListPos<OptionalParameter>.Empty }
    | OptParamsListNonEmpty
      { new ImmutableListPos<OptionalParameter>($1 :> ResizeArray<OptionalParameter>, getPos parseState) }

OptParamsListNonEmpty:
    | OptParam
      { let mutable x = new ResizeArray<OptionalParameter>() in x.Add($1); x }
    | OptParamsListNonEmpty COMMA OptParam
      { $1.Add($3); $1 }

OptParam:
    | id
      { new OptionalParameter($1, getPos parseState) }
    | id EQUALS Expression
      { new OptionalParameter($1, $3, getPos parseState) }


//------------------------------------------------------------------------------
// L-system definition.
//------------------------------------------------------------------------------

MaybeLsystemBind:
    | LSYSTEM id OptExprParams LsystemBody
      { let lsys = new Lsystem($3, $4, getPosRange parseState 3 4) in
        Some (new Binding($2, lsys, getPos parseState)) }
    | LSYSTEM error LsystemBody
      { logErrorPos (getPosBetween parseState 1 3) "Lsystem name and params excpected.";
        None }

OptExprParams:
    |
      { ImmutableListPos<OptionalParameter>.Empty }
    | ExprParams
      { $1 }

LsystemBody:
    | LBRACE LsysStatementsList RBRACE
      { new ImmutableListPos<ILsystemStatement>($2 :> ResizeArray<ILsystemStatement>, getPosI parseState 1, getPosI parseState 3, getPos parseState)  }

LsysStatementsList:
    |
      { new ResizeArray<ILsystemStatement>() }
    | LsysStatementsList LsysStatement
      { $1.Add($2); $1 }

LsysStatement:
    | MaybeRewriteRule
      { match $1 with
        | Some(rr) -> rr :> ILsystemStatement
        | None -> new EmptyStatement(getPos parseState, true) :> ILsystemStatement }
    | MaybeBinding
      { match $1 with
        | Some(bind) -> bind :> ILsystemStatement
        | None -> new EmptyStatement(getPos parseState, true) :> ILsystemStatement }
    | MaybeInterpretBind
      { match $1 with
        | Some(iBind) -> iBind :> ILsystemStatement
        | None -> new EmptyStatement(getPos parseState, true) :> ILsystemStatement }
    | SEMI
      { new EmptyStatement(getPos parseState) :> ILsystemStatement }
    | error
      { logErrorPos getLastErrorPos "Excpected L-System statement.";
        new EmptyStatement(ThreadStatic.LasErrorPos, true) :> ILsystemStatement }

MaybeSymbolListBind:
    | SET id EQUALS LsystemSymbolList SEMI
      { let symList = new LsystemSymbolList($4) in
        Some (new Binding($2, symList, getPos parseState)) }
    | SET error SEMI
      { logErrorPos (getPosBetween parseState 1 3) "Symbols definition excpected.";
        None }

MaybeInterpretBind:
    | INTERPRET LsystemSymbolList AS id OptExpressionsListParen SEMI
      { Some (new InterpretationBinding($2, $4, $5, getPos parseState)) }
    | INTERPRET error SEMI
      { logErrorPos (getPosBetween parseState 1 3) "Symbols interpretation binding excpected.";
        None }


//------------------------------------------------------------------------------
// L-system's rewrite rule.
//------------------------------------------------------------------------------

MaybeRewriteRule:
    | REWRITE OptRrCtxt LsystemSymbol OptRrCtxt OptRrExprBinds OptRrCondition TO RrReplacList SEMI
      { Some (new RewriteRule($3, $2, $4, $5, $6, $8, getPos parseState)) }
    | REWRITE OptRrCtxt LsystemSymbol OptRrCtxt OptRrExprBinds OptRrCondition TO error SEMI
      { logErrorPos (getPosBetween parseState 7 9) "Excpected rewrite rule replacement."
        Some (new RewriteRule($3, $2, $4, $5, $6, ImmutableListPos<RewriteRuleReplacement>.Empty, getPos parseState)) }
    | REWRITE error SEMI
      { logErrorPos (getPosBetween parseState 1 3) "Excpected rewrite rule.";
        None }

OptRrCtxt:
    |
      { ImmutableListPos<LsystemSymbol>.Empty }
    | LBRACE LsystemSymbolList RBRACE
      { $2.AddSeparators(getPosI parseState 1, getPosI parseState 3, getPos parseState) }
    | LBRACE error RBRACE
      { logErrorPos (getPosBetween parseState 1 3) "Excpected symbol patterns as context.";
        ImmutableListPos<LsystemSymbol>.Empty }

OptRrExprBinds:
    |
      { ImmutableListPos<Binding>.Empty }
    | WITH
      { logNoticePos (getPosI parseState 1) "Empty variable definition block found.";
        ImmutableListPos<Binding>(getStartPos parseState) }
    | WITH RrExprBindsListNonEmpty
      { new ImmutableListPos<Binding>($2 :> ResizeArray<Binding>, getPos parseState) }
    | WITH error
      { logError parseState "Excpected variable definitions separated by colon.";
        ImmutableListPos<Binding>(getStartPos parseState) }

OptRrCondition:
    |
      { Expression.Empty }
    | WHERE
      { logNoticePos (getPosI parseState 1) "Empty condition found.";
        new Expression(getEndPos parseState) }
    | WHERE ExpressionNonEmpty
      { $2 }
    | WHERE error
      { logError parseState "Excpected condition expression.";
        new Expression(getEndPos parseState) }

RrReplacList:
    |
      { logNoticePos (getStartPos parseState) "Empty replacement block found, you can use keyword `nothing` to improve source code readability.";
        ImmutableListPos<RewriteRuleReplacement>.Empty }
    | RrReplacListNonEmpty
      { new ImmutableListPos<RewriteRuleReplacement>($1 :> ResizeArray<RewriteRuleReplacement>, getPos parseState) }

RrReplacListNonEmpty:
    | RrReplac
      { let mutable x = new ResizeArray<RewriteRuleReplacement>() in x.Add($1); x }
    | RrReplacListNonEmpty OR TO RrReplac
      { $1.Add($4); $1 }

RrReplac:
    | RrReplacSymbols OptRrWeight
      { new RewriteRuleReplacement($1, $2, getPos parseState) }

RrReplacSymbols:
    | NOTHING
      { new ImmutableListPos<LsystemSymbol>(getPos parseState) }
    | LsystemSymbolListNonEmpty
      { new ImmutableListPos<LsystemSymbol>($1 :> ResizeArray<LsystemSymbol>, getPos parseState) }

OptRrWeight:
    |
      { Expression.Empty }
    | WEIGHT
      { logNoticePos (getPosI parseState 1) "Empty probability weight found.";
        new Expression(getEndPos parseState) }
    | WEIGHT ExpressionNonEmpty
      { $2 }
    | WEIGHT error
      { logError parseState "Excpected probability weight (expression).";
        new Expression(getEndPos parseState) }



RrExprBind:
    | id EQUALS Expression
      { new Binding($1, $3, getPos parseState) }

RrExprBindsListNonEmpty:
    | RrExprBind
      { let mutable x = new ResizeArray<Binding>() in x.Add($1); x }
    | RrExprBindsListNonEmpty COMMA RrExprBind
      { $1.Add($3); $1 }


//------------------------------------------------------------------------------
// L-system's symbols (also called `modules` in some L-system literature).
//------------------------------------------------------------------------------

LsystemSymbol:
    | Symbol OptExpressionsListParen
      { new LsystemSymbol($1, $2, getPos parseState) }

OptExpressionsListParen:
    |
      { ImmutableListPos<Expression>.Empty }
    | LPAREN ExpressionsList RPAREN
      { ($2 :> ImmutableListPos<Expression>).AddSeparators(getPosI parseState 1, getPosI parseState 3) }

LsystemSymbolList:
    |
      { ImmutableListPos<LsystemSymbol>.Empty }
    | LsystemSymbolListNonEmpty
      { new ImmutableListPos<LsystemSymbol>($1 :> ResizeArray<LsystemSymbol>, getPos parseState) }

LsystemSymbolListNonEmpty:
    | LsystemSymbol
      { let mutable x = new ResizeArray<LsystemSymbol>() in x.Add($1); x }
    | LsystemSymbolListNonEmpty LsystemSymbol
      { $1.Add($2); $1 }

Symbol:
    | ID
      { $1 }
    | OPERATOR
      { $1 }
    | LBRACK
      { $1 }
    | RBRACK
      { $1 }


//------------------------------------------------------------------------------
// Expressions.
//------------------------------------------------------------------------------

Expression:
    |
      { logError parseState "Excpected non-empty expression.";
        new Expression(getStartPos parseState) }
    | ExpressionMembersNonEmpty
      { new Expression($1, getPos parseState) }

ExpressionNonEmpty:
    | ExpressionMembersNonEmpty
      { new Expression($1, getPos parseState) }

ExpressionMembersNonEmpty:
    | ExprMember
      { let mutable x = new ResizeArray<IExpressionMember>() in x.Add($1); x }
    | ExpressionMembersNonEmpty ExprMember
      { $1.Add($2); $1 }

ExprMember:
    | FLOAT
      { let (value, fmt) = $1 in
        new FloatConstant(value, fmt, getPos parseState) :> IExpressionMember }
    | id
      { $1 :> IExpressionMember }
    | ExpressionsArray
      { $1 :> IExpressionMember }
    | OPERATOR
      { new Operator($1, getPos parseState) :> IExpressionMember }
    | ExprIndexer
      { $1 :> IExpressionMember }
    | ExprFun
      { $1 :> IExpressionMember }
    | ExprParen
      { $1 :> IExpressionMember }


ExpressionsArray:
    | LBRACE ExpressionsList RBRACE
      { new ExpressionsArray($2, getPosI parseState 1, getPosI parseState 3) }
    | LBRACE error RBRACE
      { logErrorPos (getPosBetween parseState 1 3) "Excpected expressions separated by comma.";
        new ExpressionsArray(getPos parseState) }

ExpressionsList:
    |
      { new ImmutableListPos<Expression>(getPos parseState) }
    | ExpressionsListNonEmpty
      { new ImmutableListPos<Expression>($1 :> ResizeArray<Expression>, getPos parseState) }

ExpressionsListNonEmpty:
    | ExpressionNonEmpty
      { let mutable x = new ResizeArray<Expression>() in x.Add($1); x }
    | ExpressionsListNonEmpty COMMA Expression
      { $1.Add($3); $1 }
    | ExpressionsListNonEmpty COMMA error
      { logErrorPos (getPosFromTo (getPosI parseState 2) (getPos parseState)) "Invalid expression in array.";
        $1 }

ExprIndexer:
    | LBRACK Expression RBRACK
      { new ExpressionIndexer($2, getPos parseState) }

// explicit ID to avoid shift/reduce conflict, dont know how to do just with `id` (tried `%prec ID` in many places)
ExprFun:
    | ID LPAREN ExpressionsList RPAREN
      { let id = new Identificator($1, getPos parseState) in
        let args = $3.AddSeparators(getPosI parseState 2, getPosI parseState 4)
        new ExpressionFunction(id, args, getPos parseState) :> IExpressionMember }

ExprParen:
    | LPAREN Expression RPAREN
      { new ExpressionBracketed($2, getPos parseState) }


//------------------------------------------------------------------------------
// Other.
//------------------------------------------------------------------------------

id:
    | ID
      { new Identificator($1, getPos parseState) }

IdsCommaList:
    |
      { new ImmutableListPos<Identificator>(getPos parseState) }
    | IdsCommaListNonEmpty
      { new ImmutableListPos<Identificator>($1 :> ResizeArray<Identificator>, getPos parseState) }

IdsCommaListNonEmpty:
    | id
      { let mutable x = new ResizeArray<Identificator>() in x.Add($1); x }
    | IdsCommaListNonEmpty COMMA id
      { $1.Add($3); $1 }