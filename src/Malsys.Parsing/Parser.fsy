
//------------------------------------------------------------------------------
// Header of parser file.
//------------------------------------------------------------------------------

%{

open System
open Microsoft.FSharp.Text.Parsing

open Logger
open Malsys
open Malsys.Ast



// This function is called by the generated parser code. Returning initiates error recovery.
// Saves last error position to thread-static message logger.
let parse_error_rich = Some (fun (ctxt: ParseErrorContext<_>) ->
   Logger.setErrPos (new Position(ctxt.ParseState.ResultRange))  )


let getLastErrorPos = Logger.getLastErrPos


let logMsg msgType (parserState : IParseState) =
    logMessagePos msgType (new Position(parserState.ResultRange)) Array.empty;
    ()

let logMsgPos msgType pos =
    logMessagePos msgType pos Array.empty;
    ()


let getPos (parserState : IParseState) =
    new Position(parserState.ResultRange)

let getPosI (parserState : IParseState) index =
    new Position(parserState.InputRange(index))

let getPosRange (parserState : IParseState) fromI toI =
    new Position((fst (parserState.InputRange(fromI)), snd (parserState.InputRange(toI))))

let getPosFromTo (fromPos : Position) (toPos : Position) =
    new Position(fromPos.BeginLine, fromPos.BeginColumn, toPos.EndLine, toPos.EndColumn)

let getPosBetween (parserState : IParseState) fromI toI =
    new Position((snd (parserState.InputRange(fromI)), fst (parserState.InputRange(toI))))

let getStartPos (parserState : IParseState) =
    let startPos = fst parserState.ResultRange
    new Position(startPos, startPos)

let getEndPos (parserState : IParseState) =
    let endPos = snd parserState.ResultRange
    new Position(endPos, endPos)

let getInpuFile (parserState : IParseState) =
    (fst parserState.ResultRange).FileName


let optionToStatement parseState (option : Option<#ILsystemStatement>) =
    match option with
        | Some(value) -> value
        | None -> new EmptyStatement(getPos parseState) :> ILsystemStatement

type ImmutableListPos_LsystemSymbol = ImmutableListPos<LsystemSymbol>

%}


//------------------------------------------------------------------------------
// Tokens lists.
//------------------------------------------------------------------------------

%token <string> ID
%token <Keyword> AS COMPONENT CONFIGURATION CONNECT CONSIDER CONTAINER DEFAULT FUN INTERPRET LET
%token <Keyword> LSYSTEM NOTHING OR PROCESS RETURN REWRITE SET THIS TO TYPEOF USE WEIGHT WITH WHERE
%token EQUALS SEMI COMMA QMARK COLON
%token LPAREN RPAREN LBRACE RBRACE
%token <float * ConstantFormat> FLOAT
%token <string> OPERATOR LBRACK RBRACK DOT
%token EOF


//------------------------------------------------------------------------------
// Priorities of tokens.
//------------------------------------------------------------------------------

// ID . LPAREN -> ExprFunc (not ExprMember ExprParen)
%nonassoc ID
%nonassoc LPAREN


//------------------------------------------------------------------------------
// Start (enter) rules and types.
//------------------------------------------------------------------------------

%start ParseInput
%type <InputBlock> ParseInput

// helper start rules especially for unit testing of parser

%start ParseExpression
%type <Expression> ParseExpression

%start ParseSymbols
%type <ImmutableListPos_LsystemSymbol> ParseSymbols

%%


//------------------------------------------------------------------------------
// Start rules.
//------------------------------------------------------------------------------

ParseInput:
    | InputStatementsList EOF
      { let sourceName = getInpuFile parseState in
        let statements = new ImmutableListPos<IInputStatement>($1 :> ResizeArray<IInputStatement>, getPos parseState) in
        new InputBlock(sourceName, statements) }


ParseExpression:
    | ExpressionNonEmpty EOF
      { $1 }

ParseSymbols:
    | LsystemSymbolList EOF
      { $1 }


//------------------------------------------------------------------------------
// Input.
//------------------------------------------------------------------------------

InputStatementsList:
    |
      { new ResizeArray<IInputStatement>() }
    | InputStatementsList InputStatement
      { $1.Add($2); $1 }

InputStatement:
    | ConstDef
      { ($1 :> IStatement) :?> IInputStatement }
    | FunDef
      { ($1 :> IStatement) :?> IInputStatement }
    | LsystemDef
      { $1 :> IInputStatement }
    | ProcessConfig
      { $1 :> IInputStatement }
    | ProcessStatement
      { ($1 :> IStatement) :?> IInputStatement }
    | SEMI
      { new EmptyStatement(getPos parseState) :> IInputStatement }


//------------------------------------------------------------------------------
// Constant definition.
//------------------------------------------------------------------------------

ConstDef:
    | LET id EQUALS Expression SEMI
      { new ConstantDefinition($2, $4, getPos parseState) :> IStatement }
    | LET error SEMI
      { logMsgPos ParsserMessage.ConstDefInvalid (getPosBetween parseState 1 3);
        new EmptyStatement(getPos parseState) :> IStatement }

//------------------------------------------------------------------------------
// Function definition.
//------------------------------------------------------------------------------

FunDef:
    | FUN id OptParamsParens FunBody
      { new FunctionDefinition($2, $3, $4, getPos parseState) :> IStatement }
    | FUN id error FunBody
      { logMsgPos ParsserMessage.ExcpectedParams (getPosBetween parseState 2 4);
        new EmptyStatement(getPos parseState) :> IStatement }

FunBody:
    | LBRACE FunStatementsList RBRACE
      { new ImmutableListPos<IFunctionStatement>($2 :> ResizeArray<IFunctionStatement>, getPosI parseState 1, getPosI parseState 3, getPos parseState)  }
    | LBRACE error RBRACE
      { logMsgPos ParsserMessage.FunStatementsInvalid (getPosBetween parseState 1 3);
        new ImmutableListPos<IFunctionStatement>(getPosI parseState 1, getPosI parseState 3, getPos parseState) }

FunStatementsList:
    |
      { new ResizeArray<IFunctionStatement>() }
    | FunStatementsList FunStatement
      { $1.Add($2); $1 }

FunStatement:
    | ConstDef
      { $1 :?> IFunctionStatement }
    | RETURN Expression SEMI
      { ($2) :> IFunctionStatement }


//------------------------------------------------------------------------------
// L-system definition.
//------------------------------------------------------------------------------

LsystemDef:
    | LSYSTEM id OptParams LsysBody
      { new LsystemDefinition($2, $3, $4, getPos parseState) :> IInputStatement }
    | LSYSTEM error LsysBody
      { logMsgPos ParsserMessage.LsystemHeaderInvalid (getPosBetween parseState 1 3);
        new EmptyStatement(getPos parseState) :> IInputStatement }

LsysBody:
    | LBRACE LsysStatementsList RBRACE
      { new ImmutableListPos<ILsystemStatement>($2 :> ResizeArray<ILsystemStatement>, getPosI parseState 1, getPosI parseState 3, getPos parseState)  }
    | LBRACE error RBRACE
      { logMsgPos ParsserMessage.LsystemStatementsInvalid (getPosBetween parseState 1 3);
        new ImmutableListPos<ILsystemStatement>(getPosI parseState 1, getPosI parseState 3, getPos parseState)  }

LsysStatementsList:
    |
      { new ResizeArray<ILsystemStatement>() }
    | LsysStatementsList LsysStatement
      { $1.Add($2); $1 }

LsysStatement:
    | ConstDef
      { $1 :?> ILsystemStatement }
    | FunDef
      { $1 :?> ILsystemStatement }
    | RewriteRule
      { $1 :> ILsystemStatement }
    | SymbolsConstDef
      { $1 :> ILsystemStatement }
    | SymbolsInterpretDef
      { $1 :> ILsystemStatement }
    | ProcessStatement
      { ($1 :> IStatement) :?> ILsystemStatement }
    | SEMI
      { new EmptyStatement(getPos parseState) :> ILsystemStatement }

SymbolsConstDef:
    | SET id EQUALS LsystemSymbolList SEMI
      { new SymbolsConstDefinition($2, $4, getPos parseState) :> ILsystemStatement }
    | SET error SEMI
      { logMsgPos ParsserMessage.SymbolsConstDefInvalid (getPosBetween parseState 1 3);
        new EmptyStatement(getPos parseState) :> ILsystemStatement }

SymbolsInterpretDef:
    | INTERPRET LsystemSymbolList AS id OptExpressionsListParen SEMI
      { new SymbolsInterpretDef($2, $4, $5, getPos parseState) :> ILsystemStatement }
    | INTERPRET error SEMI
      { logMsgPos ParsserMessage.SymbolsInterpretationInvalid (getPosBetween parseState 1 3);
        new EmptyStatement(getPos parseState) :> ILsystemStatement }


//------------------------------------------------------------------------------
// L-system's rewrite rule.
//------------------------------------------------------------------------------

RewriteRule:
    | REWRITE OptRrCtxt LsystemSymbol OptRrCtxt OptRrLocalConsts OptRrCondition TO RrReplacList SEMI
      { new RewriteRule($3, $2, $4, $5, $6, $8, getPos parseState) :> ILsystemStatement }
    | REWRITE OptRrCtxt LsystemSymbol OptRrCtxt OptRrLocalConsts OptRrCondition TO error SEMI
      { logMsgPos ParsserMessage.RrReplacementInvalid (getPosBetween parseState 7 9);
        new RewriteRule($3, $2, $4, $5, $6, ImmutableListPos<RewriteRuleReplacement>.Empty, getPos parseState) :> ILsystemStatement }
    | REWRITE error SEMI
      { logMsgPos ParsserMessage.RewriteRuleInvalid (getPosBetween parseState 1 3);
        new EmptyStatement(getPos parseState) :> ILsystemStatement }

OptRrCtxt:
    |
      { ImmutableListPos<LsystemSymbol>.Empty }
    | LBRACE LsystemSymbolList RBRACE
      { $2.AddSeparators(getPosI parseState 1, getPosI parseState 3, getPos parseState) }
    | LBRACE error RBRACE
      { logMsgPos ParsserMessage.SymbolsPatternInvalid (getPosBetween parseState 1 3);
        ImmutableListPos<LsystemSymbol>.Empty }

OptRrLocalConsts:
    |
      { ImmutableListPos<ConstantDefinition>.Empty }
    | WITH
      { logMsgPos ParsserMessage.EmptyRrConstsDefBlock (getPosI parseState 1);
        ImmutableListPos<ConstantDefinition>(getStartPos parseState) }
    | WITH RrLocalConstsListNonEmpty
      { new ImmutableListPos<ConstantDefinition>($2 :> ResizeArray<ConstantDefinition>, getPos parseState) }
    | WITH error
      { logMsg ParsserMessage.RrConstsDefInvalid parseState;
        ImmutableListPos<ConstantDefinition>(getStartPos parseState) }

OptRrCondition:
    |
      { Expression.Empty }
    | WHERE
      { logMsgPos ParsserMessage.EmptyRrConditionBlock (getPosI parseState 1);
        new Expression(getEndPos parseState) }
    | WHERE ExpressionNonEmpty
      { $2 }
    | WHERE error
      { logMsg ParsserMessage.RrConditionInvalid parseState;
        new Expression(getEndPos parseState) }

RrReplacList:
    |
      { logMsgPos ParsserMessage.EmptyRrReplacementBlock (getStartPos parseState);
        ImmutableListPos<RewriteRuleReplacement>.Empty }
    | RrReplacListNonEmpty
      { new ImmutableListPos<RewriteRuleReplacement>($1 :> ResizeArray<RewriteRuleReplacement>, getPos parseState) }

RrReplacListNonEmpty:
    | RrReplac
      { let mutable x = new ResizeArray<RewriteRuleReplacement>() in x.Add($1); x }
    | RrReplacListNonEmpty OR TO RrReplac
      { $1.Add($4); $1 }

RrReplac:
    | RrReplacSymbols OptRrWeight
      { new RewriteRuleReplacement($1, $2, getPos parseState) }

RrReplacSymbols:
    | NOTHING
      { new ImmutableListPos<LsystemSymbol>(getPos parseState) }
    | LsystemSymbolListNonEmpty
      { new ImmutableListPos<LsystemSymbol>($1 :> ResizeArray<LsystemSymbol>, getPos parseState) }

OptRrWeight:
    |
      { Expression.Empty }
    | WEIGHT
      { logMsg ParsserMessage.EmptyRrProbabilityBlock parseState;
        new Expression(getEndPos parseState) }
    | WEIGHT ExpressionNonEmpty
      { $2 }
    | WEIGHT error
      { logMsg ParsserMessage.RrProbabilityInvalid parseState;
        new Expression(getEndPos parseState) }



RrExprConst:
    | id EQUALS Expression
      { new ConstantDefinition($1, $3, getPos parseState) }

RrLocalConstsListNonEmpty:
    | RrExprConst
      { let mutable x = new ResizeArray<ConstantDefinition>() in x.Add($1); x }
    | RrLocalConstsListNonEmpty COMMA RrExprConst
      { $1.Add($3); $1 }


//------------------------------------------------------------------------------
// L-system's symbols (also called `modules` in some L-system literature).
//------------------------------------------------------------------------------

LsystemSymbol:
    | Symbol OptExpressionsListParen
      { new LsystemSymbol($1, $2, getPos parseState) }

OptExpressionsListParen:
    |
      { ImmutableListPos<Expression>.Empty }
    | LPAREN ExpressionsList RPAREN
      { ($2 :> ImmutableListPos<Expression>).AddSeparators(getPosI parseState 1, getPosI parseState 3) }

LsystemSymbolList:
    |
      { ImmutableListPos<LsystemSymbol>.Empty }
    | LsystemSymbolListNonEmpty
      { new ImmutableListPos<LsystemSymbol>($1 :> ResizeArray<LsystemSymbol>, getPos parseState) }

LsystemSymbolListNonEmpty:
    | LsystemSymbol
      { let mutable x = new ResizeArray<LsystemSymbol>() in x.Add($1); x }
    | LsystemSymbolListNonEmpty LsystemSymbol
      { $1.Add($2); $1 }

Symbol:
    | ID
      { $1 }
    | OPERATOR
      { $1 }
    | LBRACK
      { $1 }
    | RBRACK
      { $1 }
    | DOT
      { $1 }


//------------------------------------------------------------------------------
// Parameters.
//------------------------------------------------------------------------------

OptParams:
    |
      { ImmutableListPos<OptionalParameter>.Empty }
    | OptParamsParens
      { $1 }

OptParamsParens:
    | LPAREN OptParamsList RPAREN
      { ($2 :> ImmutableListPos<OptionalParameter>).AddSeparators(getPosI parseState 1, getPosI parseState 3, getPos parseState) }
    | LPAREN error RPAREN
      { logMsgPos ParsserMessage.OptionalParamsInvalid (getPosBetween parseState 1 3);
        new ImmutableListPos<OptionalParameter>(getPosI parseState 1, getPosI parseState 3, getPos parseState) }

OptParamsList:
    |
      { ImmutableListPos<OptionalParameter>.Empty }
    | OptParamsListNonEmpty
      { new ImmutableListPos<OptionalParameter>($1 :> ResizeArray<OptionalParameter>, getPos parseState) }

OptParamsListNonEmpty:
    | OptParam
      { let mutable x = new ResizeArray<OptionalParameter>() in x.Add($1); x }
    | OptParamsListNonEmpty COMMA OptParam
      { $1.Add($3); $1 }

OptParam:
    | id
      { new OptionalParameter($1, Expression.Empty, getPos parseState) }
    | id EQUALS Expression
      { new OptionalParameter($1, $3, getPos parseState) }


//------------------------------------------------------------------------------
// Expressions.
//------------------------------------------------------------------------------

Expression:
    |
      { logMsg ParsserMessage.EmptyExpression parseState;
        new Expression(getStartPos parseState) }
    | ExpressionMembersNonEmpty
      { new Expression($1, getPos parseState) }

ExpressionNonEmpty:
    | ExpressionMembersNonEmpty
      { new Expression($1, getPos parseState) }

ExpressionMembersNonEmpty:
    | ExprMember
      { let mutable x = new ResizeArray<IExpressionMember>() in x.Add($1); x }
    | ExpressionMembersNonEmpty ExprMember
      { $1.Add($2); $1 }

ExprMember:
    | FLOAT
      { let (value, fmt) = $1 in
        new FloatConstant(value, fmt, getPos parseState) :> IExpressionMember }
    | id
      { $1 :> IExpressionMember }
    | ExpressionsArray
      { $1 :> IExpressionMember }
    | OPERATOR
      { new Operator($1, getPos parseState) :> IExpressionMember }
    | ExprIndexer
      { $1 :> IExpressionMember }
    | ExprFun
      { $1 :> IExpressionMember }
    | ExprParen
      { $1 :> IExpressionMember }


ExpressionsArray:
    | LBRACE ExpressionsList RBRACE
      { new ExpressionsArray($2, getPosI parseState 1, getPosI parseState 3) }
    | LBRACE error RBRACE
      { logMsgPos ParsserMessage.ArrayExpressionInvalid (getPosBetween parseState 1 3);
        new ExpressionsArray(getPos parseState) }

ExpressionsList:
    |
      { new ImmutableListPos<Expression>(getPos parseState) }
    | ExpressionsListNonEmpty
      { new ImmutableListPos<Expression>($1 :> ResizeArray<Expression>, getPos parseState) }

ExpressionsListNonEmpty:
    | ExpressionNonEmpty
      { let mutable x = new ResizeArray<Expression>() in x.Add($1); x }
    | ExpressionsListNonEmpty COMMA Expression
      { $1.Add($3); $1 }

ExprIndexer:
    | LBRACK Expression RBRACK
      { new ExpressionIndexer($2, getPos parseState) }

// explicit ID to avoid shift/reduce conflict, don't know how to do just with `id` (already tried `%prec ID` in many places)
ExprFun:
    | ID LPAREN ExpressionsList RPAREN
      { let id = new Identificator($1, getPos parseState) in
        let args = $3.AddSeparators(getPosI parseState 2, getPosI parseState 4)
        new ExpressionFunction(id, args, getPos parseState) :> IExpressionMember }

ExprParen:
    | LPAREN Expression RPAREN
      { new ExpressionBracketed($2, getPos parseState) }


//------------------------------------------------------------------------------
// Process configuration.
//------------------------------------------------------------------------------


ProcessConfig:
    | CONFIGURATION id ProcessConfigBody
      { new ProcessConfigurationDefinition($2, $3, getPos parseState) }

ProcessConfigBody:
    | LBRACE ProcessConfigStatementsList RBRACE
      { new ImmutableListPos<IProcessConfigStatement>($2 :> ResizeArray<IProcessConfigStatement>, getPosI parseState 1, getPosI parseState 3, getPos parseState) }
    | LBRACE error RBRACE
      { logMsgPos ParsserMessage.ProcessConfigStatementsInvalid (getPosBetween parseState 1 3);
        new ImmutableListPos<IProcessConfigStatement>(getPosI parseState 1, getPosI parseState 3, getPos parseState)}

ProcessConfigStatementsList:
    |
      { new ResizeArray<IProcessConfigStatement>() }
    | ProcessConfigStatementsList ProcessConfigStatement
      { $1.Add($2); $1 }

ProcessConfigStatement:
    | ProcessComponentDef
      { $1 :> IProcessConfigStatement }
    | ProcessContainerDef
      { $1 :> IProcessConfigStatement }
    | ProcessConfigConnection
      { $1 :> IProcessConfigStatement }
    | SEMI
      { new EmptyStatement(getPos parseState) :> IProcessConfigStatement }


ProcessComponentDef:
    | COMPONENT id TYPEOF FullyQualifiedTypeId SEMI
      { new ProcessComponent($2, $4, getPos parseState) }

ProcessContainerDef:
    | CONTAINER id TYPEOF FullyQualifiedTypeId DEFAULT FullyQualifiedTypeId SEMI
      { new ProcessContainer($2, $4, $6, getPos parseState) :> IProcessConfigStatement }
    | CONTAINER id TYPEOF FullyQualifiedTypeId SEMI
      { logMsgPos ParsserMessage.ProcessConfigContainerMissingDefaultType (getPosBetween parseState 4 5);
        new EmptyStatement(getPos parseState) :> IProcessConfigStatement }

ProcessConfigConnection:
    | CONNECT id TO id DOT id SEMI
      { new ProcessConfigConnection($2, $4, $6, getPos parseState) }


FullyQualifiedTypeId:
    | ID
      { new Identificator($1, getPos parseState) }
    | FullyQualifiedTypeId DOT ID
      { new Identificator($1.Name + "." + $3, getPos parseState) }


//------------------------------------------------------------------------------
// Process statement.
//------------------------------------------------------------------------------

ProcessStatement:
    | PROCESS IdOrThisOpt WITH id ProcessComponentAssignmentList SEMI
      { let statements = new ImmutableListPos<ProcessComponentAssignment>($5 :> ResizeArray<ProcessComponentAssignment>, getPos parseState)
        new ProcessStatement($2, $4, statements, getPos parseState) :> IStatement }

IdOrThisOpt:
    |
      { Identificator.Empty }
    | THIS
      { Identificator.Empty }
    | id
      { $1 }

ProcessComponentAssignmentList:
    |
      { let mutable x = new ResizeArray<ProcessComponentAssignment>() in x }
    | ProcessComponentAssignmentList ProcessComponentAssignment
      { $1.Add($2); $1 }

ProcessComponentAssignment:
    | USE FullyQualifiedTypeId AS id
      { new ProcessComponentAssignment($2, $4, getPos parseState) }

//------------------------------------------------------------------------------
// Other.
//------------------------------------------------------------------------------

id:
    | ID
      { new Identificator($1, getPos parseState) }

IdsCommaList:
    |
      { new ImmutableListPos<Identificator>(getPos parseState) }
    | IdsCommaListNonEmpty
      { new ImmutableListPos<Identificator>($1 :> ResizeArray<Identificator>, getPos parseState) }

IdsCommaListNonEmpty:
    | id
      { let mutable x = new ResizeArray<Identificator>() in x.Add($1); x }
    | IdsCommaListNonEmpty COMMA id
      { $1.Add($3); $1 }