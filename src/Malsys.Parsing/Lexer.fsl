{
module Malsys.Parsing.Lexer

open System
open Microsoft.FSharp.Text.Lexing

open Malsys
open Malsys.Parsing.Parser


let lexeme lexbuf = LexBuffer<char>.LexemeString lexbuf

let keywords =
    [  
        ("let", LET);
        ("lsystem", LSYSTEM);
    ] |> Map.ofList
}


let digit = ['0'-'9']
let char = ['a'-'z' 'A'-'Z'] 
let whitespace = [' ' '\t']
let newline = ('\n' | '\r' '\n')

let float = digit+ ('.' digit+)? (['e' 'E'] digit+)?
let identifier = (char | '_') (char | digit | ['-' '_' '.'])*
let operators = '^'|'+'|'-'|'!'|'*'|'/'|"\\"|'%'|'<'|'>'|"<="|">="|"=="|"&&"|"^^"|"||"

let slc = "//"
let mlcBegin = "/*"
let mlcEnd = "*/"


rule tokenize = parse
    | whitespace  { tokenize lexbuf }
    | newline  { lexbuf.EndPos <- lexbuf.EndPos.NextLine; tokenize lexbuf }
    | identifier  {
        match keywords.TryFind(lexeme lexbuf) with   
        | Some(token) -> token   
        | None -> ID(lexeme lexbuf) }
    | float  { FLOAT (Double.Parse(lexeme lexbuf, System.Globalization.CultureInfo.InvariantCulture.NumberFormat)) }
    | mlcBegin  { multiLineComment lexbuf.StartPos lexbuf; tokenize lexbuf }
    | slc  {
        match singleLineComment lexbuf with
        | Some () -> tokenize lexbuf
        | None -> EOF
    }
    | operators  { OPERATOR (lexeme lexbuf) }
    | ';'  { SEMI }
    | ','  { COMMA }
    | '('  { LPAREN }
    | ')'  { RPAREN }
    | '{'  { LBRACE }
    | '}'  { RBRACE }
    | '?'  { QMARK }
    | ':'  { COLON }
    | '='  { EQUALS }
    | "->"  { RARROW }
    | eof  { EOF }
    | _  { UNRECOGNIZED (lexeme lexbuf) }
    
and multiLineComment pos = parse
    | mlcBegin  { multiLineComment lexbuf.StartPos lexbuf; multiLineComment pos lexbuf } // nesting of comments
    | mlcEnd  { () }
    | newline  { lexbuf.EndPos <- lexbuf.EndPos.NextLine; multiLineComment pos lexbuf }
    | eof  { raise <| LexerException("Unterminated comment.", pos, lexbuf.EndPos) }
    | _  { multiLineComment pos lexbuf }

and singleLineComment = parse
    | newline  { lexbuf.EndPos <- lexbuf.EndPos.NextLine; Some () }
    | eof  { None }
    | _  { singleLineComment lexbuf }
