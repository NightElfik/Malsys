{
module Malsys.Parsing.Lexer

open System
open System.Text
open System.Globalization
open Microsoft.FSharp.Text.Lexing

open Malsys
open Malsys.Ast
open Malsys.Compilers
open Malsys.Parsing.Parser

/// Returns actual string.
let lexeme lexbuf = LexBuffer<_>.LexemeString lexbuf

// for float (double) parsing
let invariantCulture = CultureInfo.InvariantCulture
let floatStyle = NumberStyles.AllowDecimalPoint ||| NumberStyles.AllowExponent

/// Sets new line information into lexbuf.
let newline (lexbuf : LexBuffer<_>) = lexbuf.EndPos <- lexbuf.EndPos.NextLine


let msgErr = CompilerMessageType.Error
let msgWarn = CompilerMessageType.Warning
let msgNtc = CompilerMessageType.Notice

/// Writes given message unto given args with range readed from given lexbuf.
let writeMessage (msgColl : MessagesCollection, _) (lexbuf : LexBuffer<_>) (msgType : CompilerMessageType) (msg : string) =
    msgColl.AddMessage(msg, msgType, new Position(lexbuf.StartPos, lexbuf.EndPos));
    ()

let writeMessagePos (msgColl : MessagesCollection, _) (pos : Position) (msgType : CompilerMessageType) (msg : string) =
    msgColl.AddMessage(msg, msgType, pos);
    ()

/// Adds given string as comment into comments list in args.
let addComment (_, cmtList : ResizeArray<Comment>) sb bPos ePos =
    cmtList.Add(new Comment(sb, new Position(bPos, ePos)));
    ()

/// Appends current string from given lexbuf to given stringbuilder.
let appendToSb lexbuf (sb : StringBuilder) =
    sb.Append(LexBuffer<_>.LexemeString lexbuf) |> ignore

/// Map of keywords.
let keywords =
    [
        ("lsystem", LSYSTEM);
        ("rewrite", REWRITE);
        ("with", WITH);
        ("where", WHERE);
        ("to", TO);
        ("weight", WEIGHT);
        ("nothing", NOTHING);
        ("consider", CONSIDER);
        ("let", LET);
        ("set", SET);
        ("fun", FUN);
    ] |> Map.ofList

}


let letter = '\Lu' | '\Ll' | '\Lt' | '\Lm' | '\Lo' | '\Nl'
let digit = '\Nd'

let firstOpChar = '!'|'$'|'%'|'&'|'*'|'+'|'.'|'\\'|'<'|'>'|'@'|'^'|'|'|'~'
let opChar = firstOpChar | '='|'?'|':'|'/'|'-'
let operator = firstOpChar opChar*
let extraOperators = "==" | '/' | '-'

let whitespace = [' ' '\t']
let newline = ('\r' '\n' | '\n' | '\r' )  // Win | Unix | Mac

let floatp = digit+ '.' digit*
let floate = digit+ ('.' digit*)? ['e' 'E'] ['+' '-']? digit+
let float = floatp | floate

let hex = ['0'-'9'] | ['A'-'F'] | ['a'-'f']
let int =
    ( digit+
    | '0' ('b'| 'B') (['0'-'1'])+
    | '0' ('o'| 'O') (['0'-'7'])+
    | '0' ('x'| 'X') hex+ )
let hexInt = '#' hex+  // hex value like colors in HTML

let connectingChar = '\Pc'
let combiningChar = '\Mn' | '\Mc'
let formattingChar = '\Cf'

let idFirstChar = letter | '_'
let idChar = letter | connectingChar | combiningChar | formattingChar | digit | ['\'']

let id = idFirstChar idChar*


// args = (MessagesCollection, ResizeArray<CommentRange>)
rule tokenize args = parse
    | whitespace
      { tokenize args lexbuf }

    | newline
      { newline lexbuf
        tokenize args lexbuf }

    | id
      { match keywords.TryFind(lexeme lexbuf) with
        | Some(token) -> token
        | None -> ID(lexeme lexbuf) }

    | int
      { let s = lexeme lexbuf in
        let n = try int64 s |> double with _ -> writeMessage args lexbuf msgErr <| sprintf "Failed to parse `%s` as integer." s; Double.NaN in
        FLOAT n }

    // #123 number -> 0x123 -> parse as hex
    | hexInt
      { let s = "0x" + (lexeme lexbuf).Substring(1) in
        let n = try int64 s |> double with _ ->  writeMessage args lexbuf msgErr <| sprintf "Failed to parse `%s` as hexagonal integer." s; Double.NaN in
        FLOAT n }

    | float
      { let mutable d = 0.0 in
        if Double.TryParse(lexeme lexbuf, floatStyle, invariantCulture, &d) then
            FLOAT d
        else
            writeMessage args lexbuf msgErr <| sprintf "Failed to parse `%s` as folating point number." (lexeme lexbuf)
            FLOAT Double.NaN }

    | "/*"
      { let sb = (new StringBuilder(128)).Append(lexeme lexbuf) in
        multiLineComment args (lexbuf.StartPos) sb 1 lexbuf }

    | "/*/"
      { addComment args (lexeme lexbuf) lexbuf.StartPos lexbuf.EndPos;
        tokenize args lexbuf  }

    | "//"
      { let sb = (new StringBuilder(64)).Append(lexeme lexbuf) in
        singleLineComment args (lexbuf.StartPos) sb lexbuf }

    | ';' { SEMI }
    | ',' { COMMA }
    | '(' { LPAREN }
    | ')' { RPAREN }
    | '{' { LBRACE }
    | '}' { RBRACE }
    | '[' { LBRACK }
    | ']' { RBRACK }
    | '?' { QMARK }
    | ':' { COLON }
    | '=' { EQUALS }
    | "->" { RARROW }

    | operator | extraOperators
      { OPERATOR (lexeme lexbuf) }

    | eof
      { EOF }

    | _
      { writeMessage args lexbuf msgErr <| sprintf  "Unrecognized input `%s`." (lexeme lexbuf);
        tokenize args lexbuf }

// nested mult-line comment
and multiLineComment args bPos sb nest = parse
    | "/*"
      { appendToSb lexbuf sb;
        multiLineComment args bPos sb (nest + 1) lexbuf }

    | "*/"
      { appendToSb lexbuf sb;
        if nest > 1 then
            multiLineComment args bPos sb (nest - 1) lexbuf
        else
            addComment args (sb.ToString()) bPos lexbuf.EndPos;
            tokenize args lexbuf }

    | newline
      { appendToSb lexbuf sb;
        newline lexbuf;
        multiLineComment args bPos sb nest lexbuf }

    | eof
      { addComment args (sb.ToString()) bPos lexbuf.StartPos;
        writeMessagePos args (new Position(bPos, lexbuf.StartPos)) msgWarn "Unterminated multiline comment.";
        EOF }

    | _
      { appendToSb lexbuf sb;
        multiLineComment args bPos sb nest lexbuf }


and singleLineComment args bPos sb = parse
    | newline
      { addComment args (sb.ToString()) bPos lexbuf.StartPos;
        newline lexbuf;
        tokenize args lexbuf }

    | eof
      { addComment args (sb.ToString()) bPos lexbuf.StartPos;
        EOF }

    | _
      { appendToSb lexbuf sb;
        singleLineComment args bPos sb lexbuf }


{
(* Just test, it works! :)
let createLexer (comments : ResizeArray<CommentRange>)  =
    let nextRule = ref (tokenize comments)
    fun lexbuf ->
        let tok = !nextRule lexbuf
        match tok with
        | DOC_BEGIN -> nextRule := docComment
        | DOC_END -> nextRule := tokenize comments
        | _ -> ()
        tok
*)
}
