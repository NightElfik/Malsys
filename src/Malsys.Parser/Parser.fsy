%{

open System
open Microsoft.FSharp.Text.Parsing

open Malsys
open Malsys.Ast

let parse_error_rich = Some (fun (ctxt: ParseErrorContext<_>) -> 
    raise <| ParserException(ctxt))

%}

%token <string> ID UNRECOGNIZED
%token LET LSYSTEM
%token EQUALS SEMI COMMA LPAREN RPAREN LBRACE RBRACE QMARK COLON RARROW
%token <float> FLOAT
%token <string> OPERATOR LT GT
%token EOF


%start start
%type <InputFile> start

%%

start:
    | StatementsList
      { new InputFile($1) }

StatementsList:
    |
      { new ResizeArray<IInputFileStatement>() }
    | StatementsList Statement
      { $1.Add($2); $1 }

Statement:
    | VarDef
      { $1 :> IInputFileStatement }
    | Lsystem
      { $1 :> IInputFileStatement }

VarDefsList:
    |
      { new ResizeArray<VariableDefinition>() }
    | VarDefsList VarDef
      { $1.Add($2); $1 }

VarDef:
    | LetKw Id EQUALS Expression SEMI
      { let (bPos, ePos) = parseState.ResultRange
        new VariableDefinition($1, $2, $4, bPos.Line, bPos.Column, ePos.Line, ePos.Column) }


Lsystem:
    | LsysKw Id LBRACE LsysStatementsList RBRACE
      { let (bPos, ePos) = parseState.ResultRange
        new Lsystem($1, $2, $4, ePos.Line, ePos.Column) }

LsysStatementsList:
    |
      { new ResizeArray<ILsystemStatement>() }
    | LsysStatementsList LsysStatement
      { $1.Add($2); $1 }

LsysStatement:
    | VarDef
      { $1 :> ILsystemStatement }
    | RewriteRule
      { $1 :> ILsystemStatement }


RewriteRule:
    //| MaybeLCtxt SymbolPattern MaybeRCtxt MaybeCondition MaybeProbab RARROW SymbolsWithParamsList SEMI
    | SymbolPattern MaybeCondition MaybeProbab RARROW SymbolsWithParamsList SEMI
      { let (bPos, ePos) = parseState.ResultRange
        new RewriteRule(null, $1, null, $2, $3, $5, bPos.Line, bPos.Column, ePos.Line, ePos.Column) }

MaybeLCtxt:
    |
      { null }
    | LT SymbolsPatternsList LT
      { let (bPos, ePos) = parseState.ResultRange
        new RrContext($2, bPos.Line, bPos.Column, ePos.Line, ePos.Column) }

MaybeRCtxt:
    |
      { null }
    | GT SymbolsPatternsList GT
      { let (bPos, ePos) = parseState.ResultRange
        new RrContext($2, bPos.Line, bPos.Column, ePos.Line, ePos.Column) }

MaybeCondition:
    |
      { null }
    | QMARK LBRACE VarDefsList Expression RBRACE
      { let (bPos, ePos) = parseState.ResultRange
        new RrCondition($3, $4, bPos.Line, bPos.Column, ePos.Line, ePos.Column) }

MaybeProbab:
    |
      { null }
    | COLON LBRACE VarDefsList Expression RBRACE
      { let (bPos, ePos) = parseState.ResultRange
        new RrProbability($3, $4, bPos.Line, bPos.Column, ePos.Line, ePos.Column) }


SymbolsPatternsList:
    |
      { new ResizeArray<SymbolPattern>() }
    | SymbolsPatternsList SymbolPattern
      { $1.Add($2); $1 }

SymbolPattern:
    | Symbol
      { let (bPos, ePos) = parseState.ResultRange
        new SymbolPattern($1, bPos.Line, bPos.Column, ePos.Line, ePos.Column) }
    | Symbol LPAREN IdsCommaList RPAREN
      { let (bPos, ePos) = parseState.ResultRange
        new SymbolPattern($1, $3, bPos.Line, bPos.Column, ePos.Line, ePos.Column) }
    
SymbolsWithParamsList:
    |
      { new ResizeArray<SymbolWithParams>() }
    | SymbolsWithParamsList SymbolWithParams
      { $1.Add($2); $1 }

SymbolWithParams:
    | Symbol
      { let (bPos, ePos) = parseState.ResultRange
        new SymbolWithParams($1, bPos.Line, bPos.Column, ePos.Line, ePos.Column) }
    | Symbol LPAREN ExpressionCommaList RPAREN
      { let (bPos, ePos) = parseState.ResultRange
        new SymbolWithParams($1, $3, bPos.Line, bPos.Column, ePos.Line, ePos.Column) }

Symbol:
    | ID
      { let (bPos, ePos) = parseState.ResultRange
        new Symbol($1, bPos.Line, bPos.Column, ePos.Line, ePos.Column) }
    | UNRECOGNIZED
      { let (bPos, ePos) = parseState.ResultRange
        new Symbol($1, bPos.Line, bPos.Column, ePos.Line, ePos.Column) }
    | OPERATOR
      { let (bPos, ePos) = parseState.ResultRange
        new Symbol($1, bPos.Line, bPos.Column, ePos.Line, ePos.Column) }


ExpressionCommaList:
    |
      { new ResizeArray<Expression>() }
    | ExpressionCommaListNonEmpty
      { $1 }

ExpressionCommaListNonEmpty:
    | Expression
      { let mutable x = new ResizeArray<Expression>() in x.Add($1); x }
    | ExpressionCommaListNonEmpty COMMA Expression
      { $1.Add($3); $1 }

        
Expression:
    | ExprExpectOperator
      { let (bPos, ePos) = parseState.ResultRange
        let x : ExpressionBuilder = $1 // otherwise error
        x.ToExpression(bPos.Line, bPos.Column, ePos.Line, ePos.Column) }

ExprExpectOperand:
    |
      { new ExpressionBuilder() }
    | ExprExpectOperator Operator
      { $1.AddOperator($2, 2uy); $1 }

ExprExpectOperandBracketed:
    | LPAREN ExprExpectOperand RPAREN
      { $2 }

ExprExpectOperator:
    | ExprExpectOperand Float
      { $1.AddConstant($2); $1 }
    | ExprExpectOperand Operator Float
      { $1.AddOperator($2, 1uy); $1.AddConstant($3); $1 }
    | ExprExpectOperand Id
      { $1.AddVariable($2); $1 }
    | ExprExpectOperand Operator Id
      { $1.AddOperator($2, 1uy); $1.AddVariable($3); $1 }
    | ExprExpectOperand ExprExpectOperandBracketed
      { $1.AddExpression($2); $1 }
    | ExprExpectOperand Operator ExprExpectOperandBracketed
      { $1.AddOperator($2, 1uy); $1.AddExpression($3); $1 }
    | ExprExpectOperand ExprFunc
      { let (id, args, bPos : Position, ePos : Position) = $2
        $1.AddFunction(id, args, bPos.Line, bPos.Column, ePos.Line, ePos.Column)
        $1 }
    | ExprExpectOperand Operator ExprFunc
      { let (id, args, bPos, ePos) = $3
        $1.AddOperator($2, 1uy)
        $1.AddFunction(id, args, bPos.Line, bPos.Column, ePos.Line, ePos.Column)
        $1 }

ExprFunc:
    | Id LPAREN ExpressionCommaList RPAREN
      { let (bPos, ePos) = parseState.ResultRange
        ($1, $3, bPos, ePos) }

IdsCommaList:
    |
      { new ResizeArray<Identificator>() }
    | IdsCommaListNonEmpty
      { $1 }

IdsCommaListNonEmpty:
    | Id
      { let mutable x = new ResizeArray<Identificator>() in x.Add($1); x }
    | IdsCommaListNonEmpty COMMA Id
      { $1.Add($3); $1 }

Id:
    | ID
      { let (bPos, ePos) = parseState.ResultRange
        new Identificator($1, bPos.Line, bPos.Column, ePos.Line, ePos.Column) }

LsysKw:
    | LSYSTEM
      { let (bPos, ePos) = parseState.ResultRange
        new Keyword(bPos.Line, bPos.Column, ePos.Line, ePos.Column) }

LetKw:
    | LET
      { let (bPos, ePos) = parseState.ResultRange
        new Keyword(bPos.Line, bPos.Column, ePos.Line, ePos.Column) }
Operator:
    | OPERATOR
      { let (bPos, ePos) = parseState.ResultRange
        new Identificator($1, bPos.Line, bPos.Column, ePos.Line, ePos.Column) }
    | LT
      { let (bPos, ePos) = parseState.ResultRange
        new Identificator($1, bPos.Line, bPos.Column, ePos.Line, ePos.Column) }
    | GT
      { let (bPos, ePos) = parseState.ResultRange
        new Identificator($1, bPos.Line, bPos.Column, ePos.Line, ePos.Column) }
Float:
    | FLOAT
      { let (bPos, ePos) = parseState.ResultRange
        new FloatConstant($1, bPos.Line, bPos.Column, ePos.Line, ePos.Column) }
    