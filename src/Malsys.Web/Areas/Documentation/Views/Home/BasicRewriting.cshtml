@**
 * Copyright © 2012 Marek Fišer [malsys@marekfiser.cz]
 * All rights reserved.
 *@
@model Malsys.Web.Models.Lsystem.SimpleLsystemProcessor

@{
	ViewBag.Title = "Basic principles of symbol rewriting system of L-systems";
	const string disqusId = "Rewriting-basics";  // Do not chage!!

	var sectionsManager = SectionsManager.CreateForLocal();
	var rootSec = sectionsManager.RootSection;

	var secSimple = rootSec.Subsection("Simple rewrite rule");
	var secOrderMatters = rootSec.Subsection("Order of rewrite rules matters");
	var secOnlyOne = rootSec.Subsection("Only one symbol can be rewritten by rewrite rule at once");
	var secNext = rootSec.Subsection("Next steps");
	
	var exampleModel = new LsystemExampleViewModel() {
		LsystemProcessor = Model,
		UnimportantLines = new int[] { -1 },
		SourceCodeTemplate = StringHelper.JoinLines(
			"lsystem {0} {{",
			"set symbols axiom = {1};",
			"set iterations = {2};",
			"{3}",
			"}}",
			"process all with SymbolPrinter;")
	};
}

<h1>@ViewBag.Title</h1>

<div class="grid-100 mobile-grid-100 grid-parent">
	<div class="grid-50 mobile-grid-100">
		<p>
			In the simplest form an L-system is a set of rewrite rules and a list of initial symbols (often called an axiom).
			In every iteration the axiom is rewritten by rewrite rules which results to another list of symbols, which is used as axiom in next iteration.
			A symbol in Malsys is represented as a string of characters but it is often jsut a single character.
			Individual symbols are separated by whitespace characters.
		</p>
	</div>
	<div class="grid-50 mobile-grid-100">
		<p>
			This chapter covers absolute basics of rewrite rule mechanics of L-systems.
			Following chapter covers how symbols can be interpreted as graphical elements to draw simple fractals.
		</p>
	</div>
</div>

<div class="grid-100 mobile-grid-100 grid-parent hideLinks toc">
	<h3>Table of contents</h3>
	@sectionsManager.TableOfContents(false, 3)
</div>

@secSimple.Html

<div class="grid-100 mobile-grid-100 grid-parent">
	<div class="grid-50 mobile-grid-100">
		<p>
			Let's define very simple L-system called <code>MyFirstLsystem</code> that will generate a sequence of symbols <code>B</code>.
			This can be done by defining some special symbol, in this case symbol <code>A</code>, that will be used to clone new symbols <code>B</code>.
		</p>
		<p>
			Now the cloning itself is cone by rewrite rule that rewrites the symbol <code>A</code> to symbols <code>B</code> and <code>A</code>.
			Notice that symbol <code>A</code> is preserved and new symbol <code>B</code> appeared.
			Other symbols in the string remains untouched.
			By setting number of iterations equal to <code>5</code> the code will generate 5 symbols <code>B</code> and symbol <code>A</code> at the end of the string.
		</p>
	</div>
</div>
@Html.Partial(MVC.Documentation.Shared.Views.LsystemExamplePartial, exampleModel.WithArgs(
		"MyFirstLsystem", "A", "5", "rewrite A to B A;"))

<div class="grid-100 mobile-grid-100 grid-parent">
	<div class="grid-50 mobile-grid-100">
		<p>
			It is possible to print result of every iteration by setting property <code>interpretEveryIteration</code> to <code>true</code>.
		</p>
	</div>
</div>

@Html.Partial(MVC.Documentation.Shared.Views.LsystemExamplePartial, exampleModel.WithArgs(
		"MyFirstLsystem", "A", "5", StringHelper.JoinLines(
			"set interpretEveryIteration = true;",
			"rewrite A to B A;")))


@secOrderMatters.Html

<div class="grid-100 mobile-grid-100 grid-parent">
	<div class="grid-50 mobile-grid-100">
		<p>
			It is possible to define any number of rewrite rules in the L-system.
			However, only one rule ca be applied to a particular symbol.
			A search for rewrite rule goes from top to bottom and ends after first match.
			This means that order of rewrite rule in L-system definition is very significant.
			Compare following two L-systems, the only difference is order of rewrite rules.
			Quite obviously the results differ.
		</p>
	</div>
</div>

@Html.Partial(MVC.Documentation.Shared.Views.LsystemExamplePartial, exampleModel.WithArgs(
		"OrderOfRulesMatters1", "A", "5", StringHelper.JoinLines("rewrite A to B A;", "rewrite A to C A;")))

<br />

@Html.Partial(MVC.Documentation.Shared.Views.LsystemExamplePartial, exampleModel.WithArgs(
		"OrderOfRulesMatters2", "A", "5", StringHelper.JoinLines( "rewrite A to C A;", "rewrite A to B A;")))


@*<h3>More complex example</h3>

<p>
	In following L-system is hidden the @Html.Link("Fibonacci sequence", "http://en.wikipedia.org/wiki/Fibonacci_sequence").
</p>

@Html.Partial(MVC.Documentation.Shared.Views.LsystemExamplePartial, exampleModel.WithArgs(
		"Fibonacci", "A", "6", StringHelper.JoinLines(
			"set interpretEveryIteration = true;",
			"rewrite A to B;",
			"rewrite B to A B;")))

<p>
	Let's count number of symbols in each iteration (starting with the axiom).
	1, 1, 2, 3, 5, 8, 13.
	Yes, these numbers are Fibonacci sequence.
	This L-system have many interesting properties, for example suffix of any iteration is the previous one.
	But let's move on some more complex topics.
</p>
*@

@secOnlyOne.Html

<div class="grid-100 mobile-grid-100 grid-parent">
	<div class="grid-50 mobile-grid-100">
		<p>
			It is not possible to create rewrite rule that rewrite groups of symbols at once.
			For example, it is not possible to rewrite symbols <code>A B</code> to <code>B A</code> using one rewrite rule.
			Every rewrite rule can rewrite only one symbol to any number (including zero) symbols.
			However, rewriting two (or more) symbols can be achieved with L-systems using context rewrite rules that will be discussed later in chapter ??.
		</p>
	</div>
</div>

@secNext.Html

<div class="grid-100 mobile-grid-100 grid-parent">
	<div class="grid-50 mobile-grid-100">
		<p>
			This chapter is intentionally very short and coveres the very basics because rewriting bare symbol (characters) is not fun.
			Following chapter ?? coveres how symbols can be interpreted as basic geometric primitives such as lines to draw some simple fractals.
		</p>
	</div>
</div>

@*
<h3>Context rewriting</h3>

<p>
	Quite advanced feature is context rewriting.
	The way how rewrite rule is matched on symbol can be restricted with context (symbols directly before and after).
	Context specification in the rewrite rule is placed in braces on the appropriate (left or right) side of rewrite rule's pattern symbol.
	If we want to rewrite <code>A</code> to <code>B</code> only if the left neighbor of
		<code>A</code> is <code>B</code>, we can write: <code class="malsys">rewrite {B} A to B;</code>.
	As an example will be signal propagation through a string of symbols.
</p>

@Html.Partial(MVC.Documentation.Shared.Views.LsystemExamplePartial, exampleModel.WithArgs(
		"SignalPropagation", "B A A A A", "5", StringHelper.JoinLines(
			"set interpretEveryIteration = true;",
			"rewrite {B} A to B;",
			"rewrite B to A;")))

<p>
	With context rewrite rules can be simulated switching two neighbor symbols.
	Imagine situation that we need rewrite rule <code class="malsys">rewrite X Y to Y X;</code>
		or <code class="malsys">rewrite Y X to X Y;</code> which are unfortunately not legal in Malsys
		(it is not possible to rewrite more than one symbol with rewrite rule).
	But we can simulate this behavior with context rewrite rules.
</p>

@Html.Partial(MVC.Documentation.Shared.Views.LsystemExamplePartial, exampleModel.WithArgs(
		"Transpose", "A  X Y  B", "3", StringHelper.JoinLines(
			"set interpretEveryIteration = true;",
			"rewrite {X} Y to X;", "rewrite X {Y} to Y;", "",
			"rewrite Y {X} to X;", "rewrite {Y} X to Y;")))

<p>
	It is also possible to simulate rewriting two symbols at once.
	Following L-system is simulating rewrite rule <code class="malsys">rewrite A B to C D E;</code> which is not legal rewrite rule of Malsys.
</p>

@Html.Partial(MVC.Documentation.Shared.Views.LsystemExamplePartial, exampleModel.WithArgs(
		"TwoAtOnce", "A  A B  B  A B  A", "1", StringHelper.JoinLines(
			"rewrite A {B} to C D E;",
			"rewrite {A} B to nothing;")))


<h3>Rewriting is parallel (concurrent)</h3>

<p>
	Another feature of L-system rewriting rules is that all symbols are rewritten <i>at once</i> (concurrently).
	You may noticed this behavior in previous examples.
</p>

<p>
	If rewriting were not parallel, lets examine one iteration of <code class="malsys">SignalPropagation</code> L-system.
	Axiom is <code>B A A A A</code>.
	The only rewrite rule matching first symbol is <code class="malsys">rewrite B to A</code>, after application this
		rewrite rule we have <code>A A A A A</code>.
	Second, third, fourth and fifth symbol do not match any rewrite rule,
		so our result is <code>A A A A A</code>.
	What is wrong?
	We have to decide which rewrite rule to use on each symbol and then apply them at once.
	Or alternatively do rewrite rule matching and context checking on old axiom.
</p>



<h3>More rewriting features</h3>

<p>
	Full list of rewriting features can be found on @Html.ActionLink("rewrite rules reference page", MVC.Documentation.SyntaxReference.RewriteRule()).
</p>*@
