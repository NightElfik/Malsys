@{
	ViewBag.Title = "Formal grammar";
}

@section scripts {
	@Content.Script("GrammarHighlighter.js", Url)
}


<h2>Formal grammar</h2>

<p>
	@Html.ActionLink("Malsys syntax", "Syntax") is described using formal grammar rules.
	Instead of describing what exactly formal grammar is (you can read it on @Html.Link("wiki", "http://en.wikipedia.org/wiki/Formal_grammar")),
		this page will explain grammar rules using examples.
</p>

<h3>Syntax of grammar rules</h3>

<p>
	Each grammar rule describes one part of Malsys input, name of rule is often connected with its actual semantic meaning, but not always.
	There are two ways how to write rule.
	The simplest rule is just name followed by equals character (<code class="grammar">=</code>) and then is one regular expression.
	Second way is to use <i>OR</i> represented as vertical bar (<code class="grammar">|</code>) to allow more regular expressions to match the rule.
</p>

<pre class="grammar">
simple = regular_expression

more_regexps =
	| regular_expression_1
	| regular_expression_2
	| regular_expression_3
	| regular_expression_4
</pre>


<h3>Tokens</h3>

<p>
	A token is a string of characters described by one or more regular expressions described on separate @Html.ActionLink("regular expressions page", "GrammarRegexps").
	Primitive tokens literals are directly in grammar to improve readability.
	Token names are upper-case to separate them from grammar rule names.
	Syntax of token definition is same as grammar rule.
	The example of following token is taken actual number definition from @Html.ActionLink("Malsys syntax", "Syntax").
</p>

<pre class="grammar">
NUMBER =
	| [0-9]+ ('.' [0-9]+)? ([eE] ('+'|'-')? [0-9]+)?
	| '0'[bB] [01]+
	| '0'[oO] [0-7]+
	| '0'[xX] ([0-9] | [a-f] | [A-F])+
	| '#' ([0-9] | [a-f] | [A-F])+
</pre>

<p>
	<code class="grammar">NUMBER</code> will match regular expression which is created by joining all defined regular expressions
		by logical <i>OR</i> (<code class="grammar">|</code>).
	Individual regular expressions are separated to improve readability, one huge regular expression would be unreadable.
</p>


<h3>Whitespace-separated members in regular expressions in grammar rule</h3>

<p>
	Very important is the regular expression on the right side of grammar rule.
	Regular expression has similar syntax described on @Html.ActionLink("regular expressions page", "GrammarRegexps") but with two significant differences.
	First difference is, that members in regular expression can be only grammar rules or tokens.
	Second and probably more important difference is that between each member in regular expression can by any number of whitespaces.
	It is like regular expression <code class="grammar">WHITESPACE*</code> around each token (where <code class="grammar">WHITESPACE</code> matches any whitespace).
	This behavior is different from regular expressions in token, where regular expressions were the same, as described on @Html.ActionLink("regular expressions page", "GrammarRegexps").
	Because of implicit whitespaces we do not have to write explicit whitespaces between every token and code is more readable.
</p>

<p>
	Regular expression <code class="grammar">'abc' '012'?</code> matches <code class="re-match">abc</code> or <code class="re-match">abc012</code>,
		but grammar rule <code class="grammar">rule = 'abc' '012'?</code> matches inputs <code class="re-match">abc</code> or
		<code class="re-match">abc012</code>, but also <code class="re-match">abc 012</code> or <code class="re-match">&nbsp;&nbsp;abc 012&nbsp;&nbsp;</code> with any whitespaces around members.
	It is because literals are implicitly converted to tokens and around them can be any number of whitespaces.
</p>


<h3>Tokenizer and whitespaces</h3>

<p>
	Because tokenizer (one, who cut input string to tokens) and parser (one, who matching grammar rules) are separated processes in Malsys, in some cases whitespace have to be used to separate tokens.
	Imagine grammar rule <code class="grammar">ab = 'a' 'b'</code>.
	Because whitespaces are optional one could think, that input <code class="re-match">ab</code> will match the rule
		<code class="grammar">ab</code>, but it won't.
	It is because tokenizer will produce one token <code class="grammar">'ab'</code> and the rule will not match it.
	But if the input will be <code class="re-match">a b</code>, rule will match it.
	This is even more obvious in real situations, for example simplified constant definition:
</p>

<pre class="grammar">
const_def = 'let' ID 'is' ID

ID = [a-z]
</pre>

<p>
	It is clear, that if we supply input <code class="re-match">letnameisvalue</code> to tokenizer, it has no clue what name and value is
		and it produces one long token and grammar rule <code class="grammar">const_def</code> won't match it.
	But if the input will be <code class="re-match">let name is value</code>, tokenizer will correctly tokenize input and rule will match it.
</p>

<p>
	On the other way, tokenizer is smart enough to separate tokens which can not overlap, for example simple function definition:
</p>

<pre class="grammar">
fun_def = 'fun' ID '(' ID? ')' '{' 'return' NUMBER ';' '}'

ID = [a-z]
</pre>

<p>
	This rule will match inputs like <code class="re-match">fun f ( x ) { return 10 ; }</code> as good as <code class="re-match">fun f(x){return 10;}</code>.
</p>


<h3></h3>



<h3>Lists</h3>

<p>
	Lists can be described in two ways.
	First way, probably easier to understand is this:
</p>

<pre class="grammar">
items_list = item (separator item)*
</pre>

<p>
	The only drawback of this method is the repetition of <code class="grammar">item</code>.
	If the <code class="grammar">item</code> is not one token, but more, we have to copy-paste its code and if we are editing the grammar,
		we have to edit two places, which can cause annoying bug, if we forget about it.
	Someone could argue, that we can add new rule to merge all members of item to one rule and use it, but then we would have 2 rules, instead of one.
	Better way is to use recursion:
</p>

<pre class="grammar">
items_list = item (separator items_list)?
</pre>

<p>
	Concrete example of this can be function's parameters list from Malsys grammar, where <code class="grammar">item = ID ('=' expression)?</code> and
		<code class="grammar">separator = ','</code>:
</p>

<pre class="grammar">
params_list = ID ('=' expression)?  (',' params_list)?
</pre>

<p>
	If input is <code class="re-match">ID, ID, ID</code> the regular expression will use <code class="grammar">params_list</code> to match more IDs.
	The progress can look like this:
</p>
<ul>
	<li><code class="grammar">params_list</code></li>
	<li><code class="grammar">ID ('=' expression)?  (',' params_list)?</code></li>
	<li><code class="grammar">ID ',' params_list</code></li>
	<li><code class="grammar">ID ',' ID ',' params_list</code></li>
	<li><code class="grammar">ID ',' ID ',' ID</code></li>
</ul>
