@{
	ViewBag.Title = "FASS curves";
	ViewBag.MainClass = "twoColumns";
}

<h2>FASS curves (space-Filling, self-Avoiding, Simple, self-Similar)</h2>

<div class="floating_container clearfix">


<div class="floating_box">
<pre class="malsys box">
/**
 * http://en.wikipedia.org/wiki/Dragon_curve
 */
lsystem DragonCurve {

	set axiom = L;
	let iterations = 10;

	// normalize line length (result image will have always same size)
	let lineLength = 2 ^ -(iterations / 2) * 256;

	rewrite L to L + R +;
	rewrite R to - L - R;

	interpret R L as DrawLine(lineLength);
	interpret + as TurnLeft(90);
	interpret - as TurnLeft(-90);

	process with SvgRenderer;

}
</pre>
</div>

<div class="floating_box">
<pre class="malsys box">
/**
 * http://en.wikipedia.org/wiki/H_tree
 */
lsystem H_tree {

	let baseStep = 128;
	let baseLineWidth = 8;

	set axiom = T(baseStep, baseLineWidth) + +
		f(baseStep) T(baseStep, baseLineWidth);
	let iterations = 8;
	let margin = 1;

	interpret + as TurnLeft(90);
	interpret f as MoveForward(4);
	interpret T F as DrawLine(4);

	interpret [ as StartBranch;
	interpret ] as EndBranch;


	rewrite T(length, width)
		with newLength = length / sqrt(2),
			newWidth = width / sqrt(2)
		to F(length, width) [ + T(newLength, newWidth) + +
			f(newLength) T(newLength, newWidth) ];

	process with SvgRenderer;

}
</pre>
</div>

<div class="floating_box">
<pre class="malsys box">
/**
 * http://en.wikipedia.org/wiki/Moore_curve
 */
lsystem MooreCurve {

	set axiom = L F L + F + L F L;
	let iterations = 4;

	interpret F as DrawLine(8);
	interpret + as TurnLeft(90);
	interpret - as TurnLeft(-90);

	rewrite L to - R F + L F L + F R -;
	rewrite R to + L F - R F R - F L +;

	process with SvgRenderer;

}
</pre>
</div>

<div class="floating_box">
<pre class="malsys box">
/**
 * Hilbert curve (also known as a Hilbert space-filling curve)
 * http://en.wikipedia.org/wiki/Hilbert_curve
 */
lsystem HilbertCurve {

	set axiom = L;
	let iterations = 5;

	interpret F as DrawLine(8);
	interpret + as TurnLeft(90);
	interpret - as TurnLeft(-90);

	rewrite L to + R F - L F L - F R +;
	rewrite R to - L F + R F R + F L -;

	process with SvgRenderer;

}
</pre>
</div>


<div class="floating_box">
<pre class="malsys box">
/**
 * http://en.wikipedia.org/wiki/Space-filling_tree
 */
lsystem SquareTree {

	set axiom = x;
	let iterations = 5;
	let initialAngle = 0;

	interpret F as DrawLine(8);
	interpret + as TurnLeft(90);
	interpret - as TurnLeft(-90);

	rewrite x to F x + + f + F x + + f + F x + + f + F x + + f +;
	rewrite F to F F;
	rewrite f to f f;

	process with SvgRenderer;

}
</pre>
</div>

<div class="floating_box">
<pre class="malsys box">
/**
 * http://en.wikipedia.org/wiki/Space-filling_tree
 */
lsystem TriangleTree {

	set axiom = x;
	let iterations = 5;
	let initialAngle = 90;

	interpret F as DrawLine(8);
	interpret f as MoveForward(8);
	interpret + as TurnLeft(60);
	interpret - as TurnLeft(-60);
	interpret | as TurnLeft(180);

	rewrite x to F x | f | + + F x | f | + + F x | f | + x +;
	rewrite F to F F;
	rewrite f to f f;

	process with SvgRenderer;

}
</pre>
</div>

<div class="floating_box">
<pre class="malsys box">
/**
 * Dekking's Church
 * Advances in Math, vol. 44, 1982, pp. 78-104
 * Works only for odd iterations.
 */
lsystem DekkingsChurch {

	set axiom = w x y z;
	let iterations = 5;

	interpret F as DrawLine(10);
	interpret + as TurnLeft(90);
	interpret - as TurnLeft(-90);

	rewrite F to nothing;
	rewrite w to F w + F - z F w - F + x;
	rewrite z to + + F - - y - F + x + + F - - y - F + x;
	rewrite y to + + F - - y + F - z;
	rewrite x to F w + F - z;

	process with SvgRenderer;

}
</pre>
</div>


</div>