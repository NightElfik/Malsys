@{
	ViewBag.Title = "Dev diary: Creating of PNG animation renderer";

	var refs = new References();
	var figs = new Figures();
}

@section submenu {
	<li>@Html.ActionLink("Curve designer", MVC.CurveDesigner.Index())</li>
	<li>@Html.ActionLink("Development diary", MVC.DevDiary.Index())</li>
	<li>@Html.ActionLink("Thesis", MVC.Home.Thesis())</li>
	<li>@Html.ActionLink("Documentation", MVC.Documentation.Home.Index())</li>
}

@section scripts {
<script type="text/javascript" src="https://www.google.com/jsapi"></script>
<script type="text/javascript">
	google.load('visualization', '1', { 'packages': ['corechart'] });
	google.setOnLoadCallback(drawChart);

	function drawChart() {

		var data = google.visualization.arrayToDataTable([
			['', 'No optimization', 'Frame trimming', 'No anti-aliasing', 'Both optimizations'],
			['Growing flower (46 frames)', 514, 436, 263, 235],
			['Dragon curve (15 frames)', 186, 174, 183, 172]
		]);

		var options = {
			vAxis: { title: 'Size [kB]', minValue: 0 },
			chartArea: { width: '85%', height: '70%' },
			legend: { position: 'bottom' }
		};

		var chart = new google.visualization.ColumnChart(document.getElementById('figSizeGraphs'));
		chart.draw(data, options);
	}
</script>
}

<h2>Dev diary: Creating of PNG animation renderer</h2>

<p>
	An L-systems are developing in iterations.
	They were developed to simulate plant growth so the progression of some L-system is more important than final state.
	To capture the progression, we need some sort of animation showing each iteration as an image -- animated image.
	There are many ways how to approach this problem but I've chosen APNG -- animated PNG.
</p>

<div class="figure">
@Html.Image(Links.Img.DevDiary.apng.Teaser_png, 800, 400, "Teaser")
</div>

<div class="errorBlock">
	Disclaimer: In this development diary are used @Html.Link("animated PNGs (APNG)", "http://en.wikipedia.org/wiki/APNG")
		as some figures.
	To fully enjoy the reading, use @Html.Link("supported browser", "http://en.wikipedia.org/wiki/APNG#Application_support", true).
</div>

<div id="toc"></div>

<h3>Possible solutions</h3>

<p>
	There are multiple ways how to create an animation of L-systems iterations.
	The first two ideas which came to my mind were scripted animation (with JavaScript) and GIF animated image.
	But I didn't like any of them so I've decided to create PNG animation.
	Pros and cons of all three techniques are summarized in following sections.
</p>


<h4>JavaScript animation</h4>

<div class="indent">
<p>
	Malsys already supports rendering L-systems to vector graphic in SVG format.
	So the easiest way is to generate bunch of SVG images and animate them using JavaScript code.
	This solution is pretty easy to implement and it will work in all common browsers.
</p>

<p>
	However, there are problems with such animation.
	It is hard to save because it is composed of many files.
	This problem is not only on the client side (if user wants to save it) but also on server side.
	For example @Html.ActionLink("L-systems Gallery", MVC.Gallery.Index()) can save only one file as main file and another one as thumbnail.
	It is possible to solve these problems but it would require large changes on server side and also I am not fan of JavaScript at all!
</p>
</div>

<h4>GIF animation</h4>

<div class="indent">
<p>
	File format which supports animations should be used to overcome problems with multiple files per animation.
	Graphics Interchange Format (GIF) is one candidate for creating L-system animations.
	All iterations can be rendered as GIF images and then converted to final animation as one GIF file.
	However, animation in GIF format has many drawbacks: @(refs.Cite("GIF", Html.Link("Graphics Interchange Format (GIF)",
			"http://en.wikipedia.org/wiki/Graphics_Interchange_Format", true) + " at Wikipedia"))
</p>

<ul>
	<li>GIF uses color palette of max. 256 distinct colors (per frame).</li>
	<li>24 bit color depth (RGB) which means no semi-transparency (pixel can be fully transparent or not transparent at all).</li>
	<li>Some software discontinue support of animated GIFs (for example Win7).</li>
	<li>Gif has relatively complicated binary format.</li>
</ul>

<p>
	Limited color palette may cause lossy compression of individual frames.
	The problem is that each frame is compressed separately which may cause noise in animation which is so typical for animated GIFs.
</p>

<p>
	GIF's binary format is relatively complicated and I want to avoid using any 3rd party libraries
		(or at least do not use those which are not written in .NET to preserve portability).
	I'd like to "<b>do it myself</b>" (to be able to tweak the solution to the perfection :).
</p>
</div>


<h4>PNG animation</h4>

<div class="indent">
<p>
	Portable Network Graphics (PNG) image format was created to improve and replace GIF.
	It has many advantages over GIF (no limited palette, simple binary format@(refs.Cite("PNG", Html.Link("Portable Network Graphics (PNG)",
			"http://en.wikipedia.org/wiki/Portable_Network_Graphics", true) + " at Wikipedia"))),
		but	PNG itself does not support animation at all.
	Extension called MNG was designed by members of the PNG Group, but it is relatively complex and has a different file signature,
		which automatically makes it incompatible with standard PNG decoders.
	Luckily, developers of the Mozilla Foundation created simpler format for PNG animations called APNG (animated PNG)
		which offers fallback to single-image display for PNG decoders that do not support APNG.
	@(refs.Cite("PNG anim", Html.Link("Animated PNG",
		"http://en.wikipedia.org/wiki/Portable_Network_Graphics#Animation", true) + " at Wikipedia"))
</p>

<p>
	APNG is by now already supported in Mozilla Firefox and Opera web browsers.
	Plugins for some other web browsers can be downloaded to display APNGs correctly.
	@(refs.Cite("APNG sup", Html.Link("Support for animated PNGs",
		"http://en.wikipedia.org/wiki/APNG#Application_support", true) + " at Wikipedia"))
	It is also possible that APNG format wont be successful and the support will not improve (or it will be deprecated), but I take that risk!
</p>
</div>

<h4>Update on WebP</h4>
<div class="indent">
<p>
	In the time of writing this (July 2012), I did not know that WebP
		@(refs.Cite("WebP", Html.Link("WebP", "http://en.wikipedia.org/wiki/WebP", true) + " at Wikipedia")) format exists and I think that
		WebP would be probably better option than animated PNG because it supports compression of animated images, much better than PNG.
</p>

<p>
	If WebP become popular, I will rewrite animations to WebP.
	Till then, enjoy APNG!
</p>
</div>


<h3>Implementation of Bitmap renderer</h3>

<p>
	This section describes creation of Bitmap renderer for Malsys.
	You can @Html.AnchorLink("skip to implementation of APNG renderer", "implApng") if you are interested more in it.
</p>

<p>
	To create APNG, PNG renderer is needed to produce images from which will be composed the APNG.
	Malsys is capable to render L-systems as SVGs, 3D scene and ASCII art (in hexagonal grid) but not as bitmap images yet.
	So first step is creation of bitmap renderer.
	Because L-systems processing is highly modular, the only think which is needed is to implement one component for rendering bitmap images.
	Such component needs to implement <code>IRenderer2D</code> interface which looks like this:
</p>

<pre class="csharp box">
public interface IRenderer2D : IRenderer {
	void InitializeState(Point startPoint, double width, ColorF color);
	void MoveTo(Point endPoint, double width, ColorF color);
	void DrawTo(Point endPoint, double width, ColorF color);
	void DrawPolygon(Polygon2D polygon);
	void DrawCircle(double radius, ColorF color);
}
</pre>

<p>
	Interface <code>IRenderer2D</code> derives from more interfaces, namely <code>IRenderer</code>, <code>IProcessComponent</code>, and <code>IComponent</code>,
		which contains methods for initializing and clearing component and signaling start and end of each iteration of processed L-system.
</p>

<p>
	Implementation of <code>IRenderer2D</code> is simple and straightforward.
	Drawing itself is done by GDI+ (System.Drawing namespace) which also allows to save the result to many image formats.
	Bitmap renderer component allows to save the result as JPEG, PNG and GIF.
</p>

@{
	var figCoordSpaces = figs.SubFigure(null, "Difference between Malsys and bitmap coordinate spaces")
		.SubImage("malsysCoords", Links.Img.DevDiary.apng.MalsysCoords_png, 280, 200, "Malsys coordinates")
		.SubImage("imageCoords", Links.Img.DevDiary.apng.ImageCoords_png, 280, 200, "Bitmap coordinates");
}

<p>
	The only non-trivial problem is conversion of coordinates from L-system coordinate space to Bitmap's.
	Malsys interprets L-systems in @Html.Link("Cartesian coordinate system", "http://en.wikipedia.org/wiki/Cartesian_coordinate_system", true)
		where positive coordinates of x axis are to the right from origin and positive coordinates of y axis are up from origin (@figs.Ref("malsysCoords", true)).
	However GDI+ bitmap have inversed y axis (positive coordinates are down from origin) and image can be drawn only to the quadrant with both coordinates positive (@figs.Ref("imageCoords", true)).
</p>

@figCoordSpaces.ToHtml()

@{
	var figShiftToZero = figs.SubFigure("zeroTransl", "Translation of image to positive coordinates")
		.SubImage(null, Links.Img.DevDiary.apng.CoordConversion_1_png, 280, 200, "Before")
		.SubImage(null, Links.Img.DevDiary.apng.CoordConversionMatrix_12_png, 218, 145, "Conversion matrix", 200)
		.SubImage(null, Links.Img.DevDiary.apng.CoordConversion_2_png, 280, 200, "After");
}

<p>
	Matrix transformations are used to convert Malsys coordinate space to Bitmap coordinate space.
	First, drawn image must be translated to be whole in positive coordinates.
	This is done by translating it horizontally by <i>−minX</i> (minimal X coordinate of drawn image) and vertically by <i>−minY</i>.
	@figs.Ref("zeroTransl") shows this transformation.
</p>

@figShiftToZero.ToHtml()

@{
	var figFlipByX = figs.SubFigure("flipByX", "Inversion of Y coordinates by flipping over X axis")
		.SubImage(null, Links.Img.DevDiary.apng.CoordConversion_2_png, 280, 200, "Before")
		.SubImage(null, Links.Img.DevDiary.apng.CoordConversionMatrix_23_png, 235, 73, "Conversion matrix", 200)
		.SubImage(null, Links.Img.DevDiary.apng.CoordConversion_3_png, 280, 200, "After");
}

<p>
	Then we need to invert Y axis.
	This can be done by flipping image over axis X.
</p>

@figFlipByX.ToHtml()

@{
	var upByHei = figs.SubFigure("upByHei", "Correction of Y coordinates (to be all positive)")
		.SubImage(null, Links.Img.DevDiary.apng.CoordConversion_3_png, 280, 200, "Before")
		.SubImage(null, Links.Img.DevDiary.apng.CoordConversionMatrix_34_png, 204, 145, "Conversion matrix", 200)
		.SubImage(null, Links.Img.DevDiary.apng.CoordConversion_4_png, 280, 200, "After")
		.SubImage(null, Links.Img.DevDiary.apng.CoordConversion_5_png, 280, 200, "After (drawed upside down)");
}

<p>
	In last step we need to translate drawn image to positive Y coordinates by translating it vertically by <i>height</i>.
</p>

@upByHei.ToHtml()

<p>
	If we multiply three conversion matrices we will get one matrix which will do all three operations at once.
	But it is not needed since Graphics class will do the hard work.
</p>

<p>
	Following source code shows configuration of Graphics class to do the transformation automatically.
	Bitmap renderer will draw in native L-system coordinates but image will be drawn correctly in transformed coordinates.
</p>

<pre class="csharp box">
Graphics g = Graphics.FromImage(bitmap);
g.TranslateTransform(-minX, -minY, MatrixOrder.Append);
g.MultiplyTransform(new Matrix(1f, 0f, 0f, -1f, 0, 0), MatrixOrder.Append);
g.TranslateTransform(0f, height, MatrixOrder.Append);
</pre>


<h3 id="implApng">Implementation of APNG renderer</h3>

<p>
	APNG renderer is extension of Bitmap renderer.
	The extension is located in <i>Cleanup</i> method which is called at the end of processing of all iterations.
	APNG renderer just takes all images (outputs) generated by its base Bitmap renderer and composes an animation from them.
</p>

<p>
	To be able to create animated PNG it is necessary to be able to decode and encode PNGs.
	Since PNG format is quite simple I decided to write own decoder and encoder classes.
</p>


<h4>PNG format</h4>

@{
	var pngChunks = figs.SubFigure()
		.SubImage("pngChunk", Links.Img.DevDiary.apng.PngChunk_png, 292, 52, "PNG chunk structure")
		.SubImage("pngImage", Links.Img.DevDiary.apng.MinimalPng_png, 384, 52, "Minimal PNG image structure");
}

<p>
	PNG image is composed from PNG signature (special 8 bytes) and blocks called chunks.
	Chunks carry all the necessary information about the PNG image.
	Each chunk have its length, type (4 chars), data and checksum (@figs.Ref("pngChunk", true)).
	There are about @Html.Link("20 different chunk types", "http://www.w3.org/TR/PNG/#11Chunks", true), but for a minimal PNG, only 3 are required:
	The IHDR chunk which specifies image size and other necessary information (see @Html.Link("official documentation", "http://www.w3.org/TR/PNG/#11IHDR", true));
		the IDAT chunk which contains compressed image data; and the IEND chunk which signalize end of PNG image.
	@(refs.Cite("PNG spec", Html.Link("Official Portable Network Graphics (PNG) Specification (Second Edition)",
		"http://www.w3.org/TR/PNG/", true)))
</p>

@pngChunks.ToHtml()

@{
	var apngComposition = figs.Image("apngComposition", Links.Img.DevDiary.apng.ApngStructure_png, 824, 374, "Composition of animated PNG from PNG images");
}

<p>
	As mentioned in the first section the Mozilla Foundation created simple format for animated PNG called APNG.
	Big advantage of this format is backwards compatibility with PNG format.
	Decoders that do not support APNG format will show the first frame (which may or may not be included in the animation).
	This is because specification of PNG says that unknown chunks should be ignored.
</p>

<p>
	Another advantage of APNG is that there is no need for decoding compressed PNG data from IDAT chunk.
	APNG composition is shown in @figs.Ref("apngComposition").
</p>

@apngComposition

<p>
	The Image header (IHDR) chunk of animation specifies size of animation, color depth, compression method and other information for all frames.
	The Animation Control Chunk (acTL) chunk contains number of frames and number of loops of the animation (zero means forever).
	The Frame Control Chunk (fcTL) is before each frame and specifies dimension and offset of the frame as well as its delay (time to be shown) and blend operation.
	For details see the APNG specification @(refs.Cite("APNG spec", Html.Link("APNG Specification", "https://wiki.mozilla.org/APNG_Specification", true))).
</p>

<p>
	One last note to PNG format.
	The IDAT chunk is usually "divided" into more smaller IDAT chunks.
	PNG standard allows more consecutive IDAT chunks which should be considered as one "data stream".
	For example standard .NET Bitmap class divides IDAT chunks to 64 kB pieces.
</p>


<h3>Implementation if PNG reader/writer</h3>

<p>
	Note: described simple PNG reader/writer can be downloaded at @Html.AnchorLink("the bottom of this page.", "down").
</p>

<p>
	To be possible to assemble APNG as shows @figs.Ref("apngComposition") we need PNG reader and writer.
	As already mentioned, we do not need to touch IDAT chunks which are encoded (compressed) so implementation of PNG reader is then relatively simple.
	The reader is designed to work as stream reader to minimize memory consumption, thus, improve performance.
	Its interface is shown in the following code snippet (unimportant members omitted).
</p>

<pre class="csharp box">
public class PngReader {
	public void ReadPngHeader();
	public ChunkReader ReadChunk();

	public class ChunkReader {
		public readonly string Name;
		public readonly uint Length;

		public int Read(byte[] buffer, int offset, int count);
	}
}
</pre>

<p>
	The usage of PngReader class shows following code which prints chunk names and lengths to the Console.
</p>

<pre class="csharp box">
using (var stream = FileStream("test.png", FileMode.Open, FileAccess.Read)) {
	var buffer = new byte[1024];
	var pngReader = new PngReader(stream);
	pngReader.ReadPngHeader();

	PngReader.ChunkReader chunkReader;
	while ((chunkReader = pngReader.ReadChunk()) != null) {
		Console.WriteLine("{0} [{1}]", chunkReader.Name, chunkReader.Length);

		int readedLength;
		while ((readedLength = chunkReader.Read(buffer, 0, buffer.Length)) > 0) {
			Console.WriteLine("Readed {0} B", readedLength);
		}
	}
}
</pre>

<p>
	PNG writer has similar design as reader.
	Only difference is that it needs to compute checksum of chunks.
	Following snippet shows interface of PNG writer (unimportant members omitted).
</p>

<pre class="csharp box">
public class PngWriter {
	public void WritePngHeader();
	public ChunkWriter StartChunk(string name, uint length);

	public class ChunkWriter {
		public readonly string Name;
		public readonly uint Length;

		public void Write(byte[] buffer, int offset, int count);
	}
}
</pre>


<h3>Results</h3>

@{
	var simplePythagorasAnim = figs.Image("simplePythagorasAnim", Links.Img.DevDiary.apng.SimplePythagorasAnim_png, 502, 382, "Simple animation of Pythagoras tree");
}

<p>
	Now we have everything what is needed for creating animated PNG.
	If we can define some simple L-system, set canvas size to ensure that every image will be exactly the same and see the result.
	Follows L-system code of "growing" Pythagoras tree and rendered result (Fig. @figs.Ref("simplePythagorasAnim")).
</p>

<pre class="malsys box">
lsystem SimpleAnimation extends Branches {

	set symbols axiom = F(128, 16);
	set iterations = 11;
	set initialAngle = 90;

	set interpretEveryIteration = true;  // to render all iterations as frames
	set canvasOriginSize = {-251, 0, 502, 382};  // to ensure same sizes of frames

	interpret E as DrawForward;
	interpret + as TurnLeft(45);
	interpret - as TurnLeft(-45);

	let sq2 = sqrt(2);

	rewrite F(step, w) to E(step, w)
		[ + F(step / sq2, w / sq2) ] - F(step / sq2, w / sq2);
}
process all with AnimationRenderer;
</pre>

@simplePythagorasAnim

@{
	var fallbackImg = figs.Image("fallbackImg", Links.Img.DevDiary.apng.SimplePythagorasAnimFallback_png, 502, 382, "Fallback image for unsupported viewers.");
}

<h4>Preview image for unsupported viewers</h4>

<p>
	Because APNG is not well supported it is important to provide reasonable default image with some information that the file is an animation.
	This image is also used in previews so it is not good idea to put there things like "Your browser sucks!".
</p>

<p>
	The easiest approach is to leave the first image as default fallback.
	This solution however do not allow to place some warning that file is animation because it would be also in animation loop.
	Next disadvantage is that animations of L-systems tend to be "empty" at beginning so preview would be white in the most cases.
</p>

<p>
	Hopefully, APNG allows to separate first (default) fallback image from animation so it is simple to put there some warning.
	I've decided to take middle frame as representative preview of animation.
	The result is shown in Figure @figs.Ref("fallbackImg")
</p>

@fallbackImg


<h3>File size reduction</h3>

<p>
	APNGs have one issue, the file size is pretty large.
	I've addressed this issue by implementing two optimizations.
</p>


<h4>Anti-aliasing</h4>

@{
	var figAa = figs.SubFigure("figAa", "Comparison of Anti-aliasing effect on quality and file size")
		.SubImage(null, Links.Img.DevDiary.apng.ApngNoTrim_png, 270, 360, "Anti-aliased (514 KB)")
		.SubImage(null, Links.Img.DevDiary.apng.ApngNoTrimNoAA_png, 270, 360, "No anti-aliasing (263 KB)");
}

<p>
	To allow better PNG compression, anti-aliasing could be turned off.
	This will result in worst quality of images but interestingly enough the savings are quite large.
	@figs.Ref("figAa") shows example of animated plant where disabling of anti-aliasing saved around 50% of file size.
</p>

@figAa.ToHtml()

<p>
	By default, anti-aliasing is on but you can turn it off using <code class="malsys">set antiAlias = false;</code>.
</p>

<h4>Trimming frames & relative positioning</h4>

<p>
	More advanced optimization is taking advantage of the fact, that APNg allows to position individual frames on arbitrary position in image.
	Thanks to this feature, background of individual frames can be trimmed and positioned to original position.
</p>

<p>
	Background of each frame is trimmed and the correct offset is set in the Frame Control Chunk (fcTL) of APNG (see @figs.Ref("apngComposition")).
	However this brings a bunch of problems.
</p>

<p>
	L-systems in Malsys are rendered in floating-point space but bitmap (png image) has integer space as well as PNG offset.
	If every frame would be trimmed in floating-point space (which is the easiest way), frames will be jumping on sub-pixel level because offset is integral.
	Trimming must be by integer-amount.
</p>

<p>
	The second problem is with background.
	Some browsers (Opera :) do not "turn on" transparency if PNG frames are without transparency channel (24 bpp) and background around frames is black.
	To avoid this behavior, we can force 32 bpp rendering by for example this <code class="malsys">set bgColor = #FF000000;</code> which will set background color to fully transparent black.
</p>


@{
	var figTrimVis = figs.Image("figTrimVis", Links.Img.DevDiary.apng.ApngTrimVis_png, 270, 370, "Visualization of frame trimming.");
}

<p>
	To visualize how trimming optimizes frames we can set background color to some non-fully transparent color
		(like <code class="malsys">set bgColor = #01AAAAAA;</code>) to see individual frames background (@figs.Ref("figTrimVis")).
	This is also a limitation, only transparent background are supported.
</p>

@figTrimVis

@{
	var figAnimFrames = figs.SubFigure("figAnimFrames", "All trimmed animation frames", true);
	string baseUrl = Links.Img.DevDiary.apng.Frames.Url();
	string baseDir = Server.MapPath(Links.Img.DevDiary.apng.Frames.URLPATH);

	foreach (var filePath in Directory.EnumerateFiles(baseDir).OrderBy(x => x)) {
		string fileName = Path.GetFileNameWithoutExtension(filePath);
		fileName = fileName.Substring(fileName.IndexOf('-') + 1);
		var size = fileName.Split('x');
		int width = int.Parse(size[0]);
		figAnimFrames.SubImage(null, baseUrl + "/" + Path.GetFileName(filePath),
			width, int.Parse(size[1]), figureWidth: Math.Max(40, width));
	}
}

<p>
	For those who do not see animation, @figs.Ref("figAnimFrames") shows all frames as individual PNGs.
</p>

@figAnimFrames.ToHtml()


@{
	var figSizeGraphs = figs.Graph("figSizeGraphs", 800, 400, "Comparison of file sizes with different optimization");

	var figSizeGraphImgs = figs.SubFigure("figSizeGraphImgs", "L-systems from " + figs.Ref("figSizeGraphs"))
		.SubImage("figPlantSub", Links.Img.DevDiary.apng.Apng_png, 270, 360, "Growing flower")
		.SubImage(null, Links.Img.DevDiary.apng.DragonApng_png, 520, 352, "Dragon curve");
}

@figSizeGraphs

@figSizeGraphImgs.ToHtml()

<p>
	By default, trimming is off but you can turn it on using <code class="malsys">set autoTrim = true;</code>.
</p>

<h3>Conclusion</h3>

<p>
	By writing this extension, I demonstrated how modular design of Malsys allows to do non-trivial extensions to L-system rendering.
	Animations are awesome!
	Also, I've learned a lot about PNG binary format structure.
</p>

<p>
	Recently I discovered WebP image format which seems to be better for animated images.
	I might write WebP renderer some day.
</p>

<h3 id="downs">Downloads</h3>

<p>
	Simple PNG reader and writer described in this article can be downloaded here.
	@Html.Link("PNG reader/writer download.", Links.Download.Png_v1_zip)
</p>

<h3>References</h3>

@refs.PrintReferences()

<h3>Comments</h3>
@{
	Html.RenderAction(MVC.Discussion.AutoThreadInline("DevDiaryApng",
		"Comments for Dev Diary about APNGs", DiscussionCategory.DevDiary));
}