@{
    ViewBag.Title = "Dev diary: SVG markup optimizations";

    var refs = new References();
    var figs = new Figures();

}

@section submenu {
    <li>@Html.ActionLink("Curve designer", MVC.CurveDesigner.Index())</li>
    <li>@Html.ActionLink("Development diary", MVC.DevDiary.Index())</li>
    <li>@Html.ActionLink("Thesis", MVC.Home.Thesis())</li>
    <li>@Html.ActionLink("Documentation", MVC.Documentation.Home.Index())</li>
}

@section scripts {
<script type="text/javascript" src="https://www.google.com/jsapi"></script>
<script type="text/javascript">
    google.load('visualization', '1', { 'packages': ['corechart'] });
    google.setOnLoadCallback(drawCharts);
    function drawCharts() {
        drawPathOptResults();
        drawOverOptResults();
    }

    function drawPathOptResults() {

        var data = google.visualization.arrayToDataTable([
            ['', 'Original size', 'Optimized size'],
            ['Circular tile', 419, 64],
            ['Sierpinski trangle', 203, 31],
            ['Dekkings church', 673, 80]
        ]);

        var dataGz = google.visualization.arrayToDataTable([
            ['', 'Original size', 'Optimized size'],
            ['Circular tile', 37, 15],
            ['Sierpinski trangle', 18, 7.2],
            ['Dekkings church', 36, 13]
        ]);

        var options = {
            vAxis: { title: 'Size [kB]', minValue: 0 },
            chartArea: { width: '70%', height: '70%' },
            legend: { position: 'bottom' }
        };

        var chart = new google.visualization.ColumnChart(document.getElementById('figPathOptResults'));
        chart.draw(data, options);

        var chart = new google.visualization.ColumnChart(document.getElementById('figPathOptResultsGz'));
        chart.draw(dataGz, options);
    }

    function drawOverOptResults() {

        var data = google.visualization.arrayToDataTable([
            ['', 'Original', 'Optimized', 'Over-optimized'],
            ['H-tree', 198, 130, 61],
            ['Hexa Gosper', 209, 169, 97],
            ['Plant', 392, 313, 131],
            ['Tree', 165, 75, 43]
        ]);

        var dataGz = google.visualization.arrayToDataTable([
            ['', 'Original', 'Optimized', 'Over-optimized'],
            ['H-tree', 13, 12, 9.1],
            ['Hexa Gosper', 22, 21, 17],
            ['Plant', 65, 46, 41],
            ['Tree', 25, 14, 12]
        ]);

        var options = {
            vAxis: { title: 'Size [kB]', minValue: 0 },
            chartArea: { width: '70%', height: '70%' },
            legend: { position: 'bottom' }
        };

        var chart = new google.visualization.ColumnChart(document.getElementById('figOverOptResults'));
        chart.draw(data, options);

        var chart = new google.visualization.ColumnChart(document.getElementById('figOverOptResultsGz'));
        chart.draw(dataGz, options);
    }
</script>
}

<h2>Dev diary: SVG markup optimizations</h2>

<div id="toc"></div>

<p>
    So far, L-systems generated by Malsys as SVG were rendered in very primitive way.
    Every line segment was one line tag of SVG.
    Thanks to GZip compression the files were not that huge because average compression ratio was more than 90%.
    The files looked like following example:
</p>

<pre class="box">
&lt;?xml version="1.0" standalone="no"?&gt;
&lt;!DOCTYPE svg PUBLIC ...&gt;
&lt;svg xmlns="http://www.w3.org/2000/svg" viewBox="-3 -169.277 582 172.277" ...&gt;

&lt;line x1="0" y1="0" x2="64" y2="0" stroke="#000000" stroke-width="2" /&gt;
&lt;line x1="64" y1="0" x2="96" y2="-55.426" stroke="#000000" stroke-width="2" /&gt;
&lt;line x1="96" y1="-55.426" x2="128" y2="0" stroke="#000000" stroke-width="2" /&gt;
&lt;line x1="128" y1="0" x2="192" y2="0" stroke="#000000" stroke-width="2" /&gt;
...
&lt;line x1="384" y1="0" x2="448" y2="0" stroke="#000000" stroke-width="2" /&gt;
&lt;line x1="448" y1="0" x2="480" y2="-55.426" stroke="#000000" stroke-width="2" /&gt;
&lt;line x1="480" y1="-55.426" x2="512" y2="0" stroke="#000000" stroke-width="2" /&gt;
&lt;line x1="512" y1="0" x2="576" y2="0" stroke="#000000" stroke-width="2" /&gt;

&lt;/svg&gt;
</pre>

<p>
    There were many sources of data redundancies and ineffectiveness:
</p>

<ol>
    <li>Coordinates have often unnecessary too many digits</li>
    <li>Some color codes can be shortened</li>
    <li>Ending point of line segment is often starting point of next line segment</li>
    <li>Colors of line segments are often the same</li>
    <li>Stroke widths of line segments are often the same</li>
</ol>

<p>
    Following text talks about how I tried to optimize SVG rendering of L-systems to achieve as small file size as possible.
</p>


<h3>Coordinates precision</h3>

<p>
    In previous version of Malsys, floating point numbers were always rounded to 3 decimal digits.
    This was unnecessary for large numbers and affected precision of small numbers.
</p>

@{
    var figSigDigComparison = figs.SubFigure("figSigDig", "Comparison of impact of significant digits on L-system precision (zoomed 2 times)")
        .SubImage(null, Links.Img.DevDiary.SvgOptimizations.HexagosperSig2_svgz, 119 * 2, 113 * 2, "2 significant digits")
        .SubImage(null, Links.Img.DevDiary.SvgOptimizations.HexagosperSig3_svgz, 119 * 2, 113 * 2, "3 significant digits")
        .SubImage(null, Links.Img.DevDiary.SvgOptimizations.HexagosperSig4_svgz, 119 * 2, 113 * 2, "4 significant digits");
}

<p>
    Better solution is to round to certain number of significant digits.
    This will save some characters and improves the precision.
    The default number of significant digits was set to 4.
    Why 4? Empirical experiment on Hexa-Gosper curve which walks on non-whole point locations shown that 3 is not enough (see @figs.Ref("figSigDig", true)).
</p>
<p>
    It is also possible to change this number to any value with
        <code>@Html.AnchorLink("outputSignificantDigitsCount", "Malsys.Processing.Components.Renderers.SvgRenderer2D", MVC.Documentation.Predefined.Components())</code>
        settable property of
        <code>@Html.AnchorLink("SvgRenderer2D", "Malsys.Processing.Components.Renderers.SvgRenderer2D", MVC.Documentation.Predefined.Components())</code>
        component.
</p>

<ul>
    <li>-87.002 → 87</li>
    <li>-105.579 → -105.6</li>
    <li>0.005 → 0.004921</li>
</ul>

@figSigDigComparison.ToHtml()


<p>
    The rounding algorithm was improved to not loose precision if it will not save any characters.
    See the following example.
</p>

<ul>
    <li>11564.781 → 11564 (not 11560)</li>
    <li>20247.025 → 20247 (not 20250)</li>
</ul>

<p>
    Since SVG standard supports scientific notation of floating point numbers, number in scientific notation it is placed to places where it save some characters.
    This is useful only when L-system is very tiny or very huge.
</p>

<ul>
    <li>0.0005791 → 5791e-6 (not 0.0005791)</li>
    <li>202478.025 → 2025e2 (not 202478)</li>
    <li>20001.2 → 2e4 (not 20001, this is neat trick)</li>
</ul>


<h3>Simplification of some color codes</h3>

<p>
    This is very simple simplification.
    If hexadecimal code of color has same pair of digits for all three channels R, G and B, they can be expressed as three-digit number instead of six.
    This might sound like very rare case but many L-systems are just black or solid color.
</p>

<ul>
    <li>#000000 → #000</li>
    <li>#FFBB00 → #FB0</li>
    <li>#33AA00 → #3A0</li>
</ul>

<h3>Lines to paths</h3>

<p>
    Second issue was redundancy of line coordinates.
    SVG has very nice tag called @Html.Link("path", "http://www.w3.org/TR/SVG/paths.html", true) which enables to concatenate consequent line segments.
    Path tag works that you can specify <i>move</i> (M) and <i>line</i> (L) actions, similarly to L-systems with <i>MoveTo</i> and <i>DrawTo</i> actions.
    So code showed in the introduction can be written as:
</p>

<pre class="box">
&lt;?xml version="1.0" standalone="no"?&gt;
&lt;!DOCTYPE svg PUBLIC ...&gt;
&lt;svg xmlns="http://www.w3.org/2000/svg" viewBox="-3 -169 582 172" ...&gt;
&lt;path stroke="#000" stroke-width="2" d="
    M 0 0
    L 64 0 L 96 -55.43 L 128 0 L 192 0
    L 224 -55.43 L 192 -110.9 L 256 -110.9 L 288 -166.3
    L 320 -110.9 L 384 -110.9 L 352 -55.43 L 384 0
    L 448 0 L 480 -55.43 L 512 0 L 576 0" /&gt;
&lt;/svg&gt;
</pre>

@{
    var figPathOptResultsGraph = figs.SubFigure("figPathOptGraphs", "Results of path tag optimization")
        .SubGraph("figPathOptResults", 400, 400, "Raw SVG sizes comparison")
        .SubGraph("figPathOptResultsGz", 400, 400, "GZippled SVG sizes comparison");

    var figPathOptResultsImgs = figs.SubFigure("figPathOptResultsImgs", "L-systems listed in " + figs.Ref("figPathOptGraphs"))
        .SubImage(null, Links.Img.DevDiary.SvgOptimizations.CircTile_svgz, 280, 280, "Circular tile")
        .SubImage(null, Links.Img.DevDiary.SvgOptimizations.SierpinskiTrangle_svgz, 286, 247, "Sierpinski trangle")
        .SubImage(null, Links.Img.DevDiary.SvgOptimizations.DekkingsChurch_svgz, 249, 285, "Dekkings church");

    var figHtreeHexaGosper = figs.SubFigure("figProblematic", "Problematic L-systems for path-groupping")
        .SubImage("Htree", Links.Img.DevDiary.SvgOptimizations.HtreeSmall_svgz, 421, 304, "H-tree (line thickness differs)")
        .SubImage("HexaGosper", Links.Img.DevDiary.SvgOptimizations.HexaGosperSmall_svgz, 349, 285, "Hexa Gosper curve (color differs)");
}

<p>
    This brings huge savings among L-systems which are one line with same thickness and color.
    This optimization is enabled by default but it can be toggled with
        <code>@Html.AnchorLink("optimizeSvg", "Malsys.Processing.Components.Renderers.SvgRenderer2D", MVC.Documentation.Predefined.Components())</code>
        settable property of
        <code>@Html.AnchorLink("SvgRenderer2D", "Malsys.Processing.Components.Renderers.SvgRenderer2D", MVC.Documentation.Predefined.Components())</code>.
    Concrete values of file sizes with and without this optimization can be found in @figs.Ref("figPathOptGraphs").
</p>

@figPathOptResultsGraph.ToHtml()
@figPathOptResultsImgs.ToHtml()

<p>
    However L-systems with varying color (@figs.Ref("Htree", true)) or thickness (@figs.Ref("HexaGosper", true)) can not use path too effectively because
        neighboring lines have different thicknesses.
</p>

@figHtreeHexaGosper.ToHtml()


<h3>"Over-optimizing"of SVGs</h3>

<p>
    It would be useful to group lines with same thickness and color to groups.
    To do that, we will need to reorder lines but this will cause different rendering result if lines are overlapping.
    Because of possibility of unpredictable results of this optimization, it is disabled by default and it can be explicitly enabled with
        <code>@Html.AnchorLink("overoptimizeSvg", "Malsys.Processing.Components.Renderers.SvgRenderer2D", MVC.Documentation.Predefined.Components())</code>
        settable property of
        <code>@Html.AnchorLink("SvgRenderer2D", "Malsys.Processing.Components.Renderers.SvgRenderer2D", MVC.Documentation.Predefined.Components())</code>.
</p>

<p>
    The L-systems with no overlapping lines or when order does not matter too much greatly benefit from reordering and file size savings are large.
    To save even more, there is two-level hierarchy of groups - by color and by line width.
    It is dynamically resolved whether it is better to have width groups with color sub-groups or vice versa.
    Implementation uses @Html.Link("SVG g tag", "http://www.w3.org/TR/SVG/struct.html#GElement", true) to group lines.
</p>

<p>
    Lastly, thanks to @Html.Link("path", "http://www.w3.org/TR/SVG/paths.html", true) element which enables not only to draw ploy-line but also jump to different location,
        line segments with same width and color are grouped to the same path tag even if they are not continuous line.
    This gives us even larger savings in L-systems which have many branches.
</p>

<p>
    Nice example to demonstrate benefit of described "over-optimization" are L-systems H-tree and rainbow-colored Hexa Gosper curve
        mentioned in @figs.Ref("figProblematic").
    Following SVG code shows how H-tree (@figs.Ref("Htree", true) was "over-optimized".
</p>

<pre class="box">
&lt;?xml version="1.0" standalone="no"?&gt;
&lt;!DOCTYPE svg PUBLIC ...&gt;
&lt;svg xmlns="http://www.w3.org/2000/svg" viewBox="-319.8 -451 639.6 454" ...&gt;
&lt;g stroke="#000"&gt;
&lt;path stroke-width="6" d="M 0 0 L 0 -256 " /&gt;
&lt;path stroke-width="5" d="M 0 -256 L -181 -256 M 0 -256 L 181 -256 " /&gt;
&lt;path stroke-width="4" d="M -181 -256 L -181 -128 M -181 -256 L -181 -384 ..." /&gt;
&lt;path stroke-width="3" d="M -181 -128 L -90.51 -128 M -181 -128 L -271.5 -128 ..." /&gt;
&lt;/g&gt;
&lt;/svg&gt;
</pre>

@{
    var figOverOptResultsGraph = figs.SubFigure("figOverOptGraphs", "Results of over-optimization")
        .SubGraph("figOverOptResults", 420, 400, "Raw SVG sizes comparison")
        .SubGraph("figOverOptResultsGz", 420, 400, "GZippled SVG sizes comparison");

    var figOverOptResultsImgs = figs.SubFigure("figOverOptResultsImgs", "Some L-systems listed in " + figs.Ref("figOverOptGraphs"))
        .SubImage("figPlantSub", Links.Img.DevDiary.SvgOptimizations.Plant3_svgz, 233, 303, "Plant")
        .SubImage(null, Links.Img.DevDiary.SvgOptimizations.Tree_svgz, 319, 301, "Tree");

    var figOverOptPlantImgs = figs.SubFigure("figOverOptPlantImgs", "Detail of over-optimization side-effect")
        .SubImage(null, Links.Img.DevDiary.SvgOptimizations.Plant3_svgz, 350, 455, "Original SVG")
        .SubImage(null, Links.Img.DevDiary.SvgOptimizations.Plant3Oo_svgz, 350, 455, "Over-optimized SVG");
}

@figOverOptResultsGraph.ToHtml()

@figOverOptResultsImgs.ToHtml()

<p>
    Notice how over-optimization "messed" up order in Plant L-system in @figs.Ref("figPlantSub").
    @figs.Ref("figOverOptPlantImgs") shows detail of over-optimization artifacts.
</p>

@figOverOptPlantImgs.ToHtml()

<h3>Conclusion</h3>

<p>
    The optimizations helped to reduce size of generated SVGs especially in RAW form.
    This can be beneficial for obtaining smaller non-gzipped images with Malsys.
</p>

<p>
    Size reduction of gzipped SVGs was lower but still significant, sometimes over 50% size reduction.
    This will help to reduce loading time of gallery.
</p>

<h4>Future work</h4>

<p>
    All optimizations were operating only with lines but Malsys can render polygons and circles as well.
    Those could benefit from described optimizations as well (for example stroke and fill of polygons).
</p>


<h3>Comments</h3>
@{
    Html.RenderAction(MVC.Discussion.AutoThreadInline("DevDiarySvgOpt",
        "Comments for Dev Diary about SVG optimizations", DiscussionCategory.DevDiary));
}