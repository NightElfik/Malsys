@model DevDiaryViewModel

@{
	var layoutMgr = Model.LayoutManager;
	var figsMgr = Model.FiguresManager;
	var codeMgr = Model.CodeListingsManager;
	codeMgr.DefaultProgLang = ProgLang.Xml;

	var rootSec = Model.SectionsManager.RootSection;

	var secSvgOptim = rootSec.Subsection("SVG optimizations");
		var subsecLines = secSvgOptim.Subsection("Lines to paths");
		var subsecCoords = secSvgOptim.Subsection("Coordinates precision");
		var subsecColorCodes = secSvgOptim.Subsection("Simplification of some color codes");
		var subsecResults = secSvgOptim.Subsection("Results");
	var secOverOptimization = rootSec.Subsection("Over-optimizing SVGs");
		var subsecOoResults = secOverOptimization.Subsection("Results");
		var subsecOoFuture = secOverOptimization.Subsection("Future work");

}

@* ================================================================================================================== *@
@* ================================================================================================================== *@
@* ================================================================================================================== *@
@if (secSvgOptim.IsVisible) {
	@secSvgOptim.Html

	var origSvg = codeMgr.Code("Original non-optimized SVG code.", @"
<?xml version=""1.0"" standalone=""no""?>
<!DOCTYPE svg PUBLIC ...>
<svg xmlns=""http://www.w3.org/2000/svg"" viewBox=""-3 -169.277 582 172.277"" ...>

<line x1=""0"" y1=""0"" x2=""64"" y2=""0"" stroke=""#000000"" stroke-width=""2"" />
<line x1=""64"" y1=""0"" x2=""96"" y2=""-55.426"" stroke=""#000000"" stroke-width=""2"" />
<line x1=""96"" y1=""-55.426"" x2=""128"" y2=""0"" stroke=""#000000"" stroke-width=""2"" />
<line x1=""128"" y1=""0"" x2=""192"" y2=""0"" stroke=""#000000"" stroke-width=""2"" />
...
<line x1=""384"" y1=""0"" x2=""448"" y2=""0"" stroke=""#000000"" stroke-width=""2"" />
<line x1=""448"" y1=""0"" x2=""480"" y2=""-55.426"" stroke=""#000000"" stroke-width=""2"" />
<line x1=""480"" y1=""-55.426"" x2=""512"" y2=""0"" stroke=""#000000"" stroke-width=""2"" />
<line x1=""512"" y1=""0"" x2=""576"" y2=""0"" stroke=""#000000"" stroke-width=""2"" />

</svg>
");

@layoutMgr.StartColumn()

	<p>
		So far, L-systems generated by Malsys as SVG were rendered in very primitive way.
		Every line segment was one tag of SVG line element.
		Thanks to GZip compression the files were not that huge because average compression ratio was more than 90%.
		The files looked like code in @origSvg.Ref.
		There were many sources of data redundancies and ineffectiveness:
	</p>

	<ol>
		<li>Ending point of many line segments was often starting point of the very next one so lines could be concatenated to polyline element,</li>
		<li>coordinates had often unnecessary too many digits like 0.333333333 because of used double precision floating point format,</li>
		<li>some color codes could be shortened like #FFFFFF to #FFF, and finally</li>
		<li>colors and stroke widths were often the same so groups could be used to optimize the markup.</li>
	</ol>

	<p>
		Following text talks about mentioned SVG markup optimizations together with some stats.
	</p>

@layoutMgr.NextColumn()
	@origSvg.Html
@layoutMgr.EndColumn()


@* ================================================================================================================== *@
@subsecLines.Html

	var optimSvg = codeMgr.Code("SVG optimized by converting lines to paths.", @"
<?xml version=""1.0"" standalone=""no""?>
<!DOCTYPE svg PUBLIC ...>
<svg xmlns=""http://www.w3.org/2000/svg"" viewBox=""-3 -169.277 582 172.277"" ...>
<path stroke=""#000000"" stroke-width=""2"" d=""
	M 0 0
	L 64 0 L 96 -55.426 L 128 0 L 192 0
	L 224 -55.426 L 192 -110.9 L 256 -110.9 L 288 -166.3
	L 320 -110.9 L 384 -110.9 L 352 -55.426 L 384 0
	L 448 0 L 480 -55.426 L 512 0 L 576 0"" />
</svg>
");

@layoutMgr.StartColumn()
	<p>
		The biggest source of redundancy are lines.
		SVG has very nice tag called @Html.Link("path", "http://www.w3.org/TR/SVG/paths.html", true)
			which enables to concatenate consequent line segments.
		Path tag works that you can specify <i>move</i> (M) and <i>line</i> (L) actions
			similarly to L-systems' <i>MoveTo</i> and <i>DrawTo</i> actions.
		Code showed in the introduction @origSvg.Ref is optimized to code in @optimSvg.Ref.
	</p>
	<p>
		This brings huge savings among L-systems which are one line with same thickness and color.
		This optimization is enabled by default but it can be toggled with
			<code>@Html.AnchorLink("optimizeSvg", "Malsys.Processing.Components.Renderers.SvgRenderer2D", MVC.Documentation.Predefined.Components())</code>
			settable property of
			<code>@Html.AnchorLink("SvgRenderer2D", "Malsys.Processing.Components.Renderers.SvgRenderer2D", MVC.Documentation.Predefined.Components())</code>.
	</p>
@layoutMgr.NextColumn()
	@optimSvg.Html
@layoutMgr.EndColumn()


@* ================================================================================================================== *@
	@subsecCoords.Html

	var figSigDigComparison = figsMgr.MultiFigure("Comparison of impact of significant digits on L-system precision (zoomed 2 times).");
	figSigDigComparison.SubImage("2 significant digits", 119 * 2, 113 * 2, Links.Img.DevDiary.SvgOptimizations.HexagosperSig2_svgz);
	figSigDigComparison.SubImage("3 significant digits", 119 * 2, 113 * 2, Links.Img.DevDiary.SvgOptimizations.HexagosperSig3_svgz);
	figSigDigComparison.SubImage("4 significant digits", 119 * 2, 113 * 2, Links.Img.DevDiary.SvgOptimizations.HexagosperSig4_svgz);

@layoutMgr.StartColumn()
	<p>
		Previously, floating point numbers were always rounded to 3 decimal digits.
		This was unnecessary for large numbers and negatively affected precision of small numbers.
		Here are some exaples:
	</p>
	<ul>
		<li>-87.002 → 87</li>
		<li>-105.579 → -105.6</li>
		<li>0.005 → 0.004921</li>
	</ul>
	<p>
		Better solution is to round to certain number of significant digits.
		This will save some characters and even improves the precision.
		The default number of significant digits was set to 4.
		Why 4?
		Empirical experiment on Hexa-Gosper curve which walks on non-whole point locations shown that 3 is not enough
		(see @figSigDigComparison.Ref).
	</p>

	<p>
		It is also possible to change this number to any value with
			<code>@Html.AnchorLink("outputSignificantDigitsCount", "Malsys.Processing.Components.Renderers.SvgRenderer2D", MVC.Documentation.Predefined.Components())</code>
			settable property of
			<code>@Html.AnchorLink("SvgRenderer2D", "Malsys.Processing.Components.Renderers.SvgRenderer2D", MVC.Documentation.Predefined.Components())</code>
			component.
	</p>

	<p>
		The rounding algorithm was improved to not loose precision if it will not save any characters.
		See the following example.
	</p>

	<ul>
		<li>11564.781 → 11564 (not 11560)</li>
		<li>20247.025 → 20247 (not 20250)</li>
	</ul>

	<p>
		Since SVG standard supports scientific notation of floating point numbers, number in scientific notation it is placed to places where it save some characters.
		This is useful only when L-system is very tiny or very huge.
	</p>

	<ul>
		<li>0.0005791 → 5791e-6 (not 0.0005791)</li>
		<li>202478.025 → 2025e2 (not 202478)</li>
		<li>20001.2 → 2e4 (not 20001, this is neat trick)</li>
	</ul>
@layoutMgr.NextColumn()

	@figSigDigComparison.Html

@layoutMgr.EndColumn()

@* ================================================================================================================== *@
	@subsecColorCodes.Html


@layoutMgr.StartColumn()
<p>
	This is very simple simplification.
	If hexadecimal code of color has same pair of digits for all three channels R, G and B, they can be expressed as three-digit number instead of six.
	This might sound like very rare case but many L-systems are just black or solid color.
</p>

<ul>
	<li>#000000 → #000</li>
	<li>#FFBB00 → #FB0</li>
	<li>#33AA00 → #3A0</li>
</ul>
@layoutMgr.EndColumn()


@* ================================================================================================================== *@
	@subsecResults.Html

	var figPathOptResultsGraph = figsMgr.MultiFigure("Results of SVG optimizations");

	var rawSvgPathChart = figsMgr.Chart(300, 300, "", "kB",
			new string[] { "", "Original size", "Optimized size" },
			chartType: "ColumnChart")
		.AddDataRow("Circular tile", 419, 64)
		.AddDataRow("Sierpinski trangle", 203, 31)
		.AddDataRow("Dekkings church", 673, 80);
	figPathOptResultsGraph.SubHtml("Raw SVG sizes comparison", rawSvgPathChart.Html);

	var gzSvgPathChart = figsMgr.Chart(300, 300, "", "kB",
			new string[] { "", "Original size", "Optimized size" },
			chartType: "ColumnChart")
		.AddDataRow("Circular tile", 37, 15)
		.AddDataRow("Sierpinski trangle", 18, 7.2)
		.AddDataRow("Dekkings church", 36, 13);
	figPathOptResultsGraph.SubHtml("G-zippled SVG sizes comparison", gzSvgPathChart.Html);

	var figPathOptResultsImgs = figsMgr.MultiFigure("L-systems listed in " + figPathOptResultsGraph.Ref);
	figPathOptResultsImgs.SubImage("Circular tile", 280, 280, Links.Img.DevDiary.SvgOptimizations.CircTile_svgz);
	figPathOptResultsImgs.SubImage("Sierpinski trangle", 286, 247, Links.Img.DevDiary.SvgOptimizations.SierpinskiTrangle_svgz);
	figPathOptResultsImgs.SubImage("Dekkings church", 249, 285, Links.Img.DevDiary.SvgOptimizations.DekkingsChurch_svgz);

@layoutMgr.StartColumn()
	<p>
		Following charts in @figPathOptResultsGraph.Ref present size reduction using all described techniques.
	</p>
@layoutMgr.EndColumn()

@layoutMgr.StartColumn()
	@figPathOptResultsGraph.Html
@layoutMgr.NextColumn()
	@figPathOptResultsImgs.Html
@layoutMgr.EndColumn()

}

@* ================================================================================================================== *@
@* ================================================================================================================== *@
@* ================================================================================================================== *@
@if (secOverOptimization.IsVisible) {
	@secOverOptimization.Html

	var figHtreeHexaGosper = figsMgr.MultiFigure("Problematic L-systems for path-groupping");
	figHtreeHexaGosper.SubImage("H-tree (line thickness differs)", 3 * 421 / 4, 3 * 304 / 4,  Links.Img.DevDiary.SvgOptimizations.HtreeSmall_svgz);
	figHtreeHexaGosper.SubImage("Hexa Gosper curve (color differs)", 3 * 349 / 4, 3 * 285 / 4, Links.Img.DevDiary.SvgOptimizations.HexaGosperSmall_svgz);


@layoutMgr.StartColumn()
	<p>
		Previous optimizations were useful only for optimizing consecutive line segments with the same color and thickness.
		It would be useful to group lines with same thickness and color to groups.
		Unfortunately in order to do that it is necessary to reorder lines.
		Reordering might cause different rendering result if lines are overlapping but in many cases order does not matter.
		Examples of such L-systems are shows in @figHtreeHexaGosper.Ref.
		Because of possibility of unpredictable results of this optimization, it is disabled by default and it can be explicitly enabled with
			<code>@Html.AnchorLink("overoptimizeSvg", "Malsys.Processing.Components.Renderers.SvgRenderer2D", MVC.Documentation.Predefined.Components())</code>
			settable property of
			<code>@Html.AnchorLink("SvgRenderer2D", "Malsys.Processing.Components.Renderers.SvgRenderer2D", MVC.Documentation.Predefined.Components())</code>.
	</p>
	<p>
		The L-systems with no overlapping lines or when order does not matter too much greatly benefit from reordering and file size savings are large.
		To save even more, there is two-level hierarchy of groups - by color and by line width.
		It is dynamically resolved whether it is better to have width groups with color sub-groups or vice versa.
		Implementation uses @Html.Link("SVG g tag", "http://www.w3.org/TR/SVG/struct.html#GElement", true) to group lines.
	</p>

	<p>
		Lastly, thanks to @Html.Link("path", "http://www.w3.org/TR/SVG/paths.html", true) element which enables not only to draw ploy-line but also jump to different location,
			line segments with same width and color are grouped to the same path tag even if they are not continuous line.
		This gives us even larger savings in L-systems which have many branches.
	</p>
@layoutMgr.NextColumn()
	@figHtreeHexaGosper.Html
@layoutMgr.EndColumn()

@* ================================================================================================================== *@
	@subsecOoResults.Html

	var widSvgOpti = codeMgr.Code("SVG optimized by groupping lines by stroke width.", @"
<?xml version=""1.0"" standalone=""no""?>
<!DOCTYPE svg PUBLIC ...>
<svg xmlns=""http://www.w3.org/2000/svg"" viewBox=""-319.8 -451 639.6 454"" ...>
<g stroke=""#000"">
<path stroke-width=""6"" d=""M 0 0 L 0 -256 "" />
<path stroke-width=""5"" d=""M 0 -256 L -181 -256 M 0 -256 L 181 -256 "" />
<path stroke-width=""4"" d=""M -181 -256 L -181 -128 M -181 -256 L -181 -384 ..."" />
<path stroke-width=""3"" d=""M -181 -128 L -90.51 -128 M -181 -128 L -271.5 ..."" />
</g>
</svg>
");

@layoutMgr.StartColumn()
	<p>
		Nice example to demonstrate benefit of described "over-optimization" are L-systems H-tree and rainbow-colored Hexa Gosper curve.
		SVG code in @widSvgOpti.Ref shows how H-tree was "over-optimized" without "damaging" the image (code is truncated).
		The SVG has as many <code>path</code> tags as many different thicknesses there is.
		The same is true for the color.
	</p>
@layoutMgr.NextColumn()
	@widSvgOpti.Html
@layoutMgr.EndColumn()

	var figOverOptResultsGraph = figsMgr.MultiFigure("Results of over-optimization");

	var overOptResultsChart = figsMgr.Chart(300, 300, "", "kB",
			new string[] { "", "Original", "Optimized", "Over-optimized" },
			chartType: "ColumnChart")
		.AddDataRow("H-tree", 198, 130, 61)
		.AddDataRow("Hexa Gosper", 209, 169, 97)
		.AddDataRow("Plant", 392, 313, 131)
		.AddDataRow("Tree", 165, 75, 43);
	figOverOptResultsGraph.SubHtml("Raw SVG sizes comparison", overOptResultsChart.Html);

	var overOptResultsGzChart = figsMgr.Chart(300, 300, "", "kB",
			new string[] { "", "Original", "Optimized", "Over-optimized" },
			chartType: "ColumnChart")
		.AddDataRow("H-tree", 13, 12, 9.1)
		.AddDataRow("Hexa Gosper", 22, 21, 17)
		.AddDataRow("Plant", 65, 46, 41)
		.AddDataRow("Tree", 25, 14, 12);
	figOverOptResultsGraph.SubHtml("GZippled SVG sizes comparison", overOptResultsGzChart.Html);


	var figOverOptResultsImgs = figsMgr.MultiFigure("Some L-systems listed in " + figOverOptResultsGraph.Ref);
	figOverOptResultsImgs.SubImage("Plant", 233, 303, Links.Img.DevDiary.SvgOptimizations.Plant3_svgz);
	figOverOptResultsImgs.SubImage("Tree", 319, 301, Links.Img.DevDiary.SvgOptimizations.Tree_svgz);

@layoutMgr.StartColumn()
	<p>
		@figOverOptResultsGraph.Ref shows results of optimization and over-optimization on several examples.
		The reduction on non-gzipped SVGs is around 60-80%, gzipped SVGs are around 30-50% smaller.
	</p>

	@figOverOptResultsGraph.Html

@layoutMgr.NextColumn()
	@figOverOptResultsImgs.Html
@layoutMgr.EndColumn()


	var figOverOptPlantImgs = figsMgr.MultiFigure("Detail of over-optimization side-effect");
	figOverOptPlantImgs.SubImage("Original SVG", 350, 455, Links.Img.DevDiary.SvgOptimizations.Plant3_svgz);
	figOverOptPlantImgs.SubImage("Over-optimized SVG", 350, 455, Links.Img.DevDiary.SvgOptimizations.Plant3Oo_svgz);

@layoutMgr.StartColumn()
	<p>
		Notice how over-optimization "messed" up order in Plant L-system in @figOverOptPlantImgs.Ref.
		However, in this case it is barely noticable and acceptable.
		Look at the bottom of the plant, the small branches were in the back and now they are in the front.
	</p>
@layoutMgr.EndColumn()

@layoutMgr.StartColumn(100)
	@figOverOptPlantImgs.Html
@layoutMgr.EndColumn()


@* ================================================================================================================== *@
	@subsecOoFuture.Html

@layoutMgr.StartColumn()
	<p>
		As an update to SVG optimization topic on July 2014, I realized that there are several tools that do the SVG optimization, for example:
	</p>
	<ul>
		<li>@StaticHtml.ExternalLink("SVG Cleaner", "https://launchpad.net/svg-cleaner"),</li>
		<li>@StaticHtml.ExternalLink("SVG Optimiser", "http://petercollingridge.appspot.com/svg_optimiser"), or</li>
		<li>@StaticHtml.ExternalLink("Grunt svgmin", "https://github.com/sindresorhus/grunt-svgmin").</li>
	</ul>
	<p>
		Optimizations described in this article are specific to L-systems but I believe that those tools would do even better job.
		Those tools would be quite simple to plug to existing pipeline but I don't like to use non-native tools in 100% managed application like Malsys.
		However, if there ever be a good reason to use them, I can consider it.
	</p>
@layoutMgr.EndColumn()

}